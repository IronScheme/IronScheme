//
//  This CSharp output file generated by Gardens Point LEX
//  Version:  0.6.2.196 (2007-11-13)
//  Machine:  UBER-VISTA
//  DateTime: 2008/05/22 07:38:30 PM
//  UserName: leppie
//  GPLEX input file <IronScheme.lex>
//  GPLEX frame file <C:\dev\IronScheme\tools\gplexx.frame>
//
//  Option settings: unicode, parser, stack, minimize, classes, compressmap, compressnext
//

#define BACKUP
#define STACK
//
// gplexx.frame
// Version 0.6.2 of 13-November-2007
// Derived from gplex.frame version of 2-September-2006. 
// Left and Right Anchored state support.
// Start condition stack. Two generic params.
// Using fixed length context handling for right anchors
//
using System;
using System.IO;
using System.Collections.Generic;
using Microsoft.Scripting;
using System.Text;
#if !STANDALONE
using gppg;
#endif


namespace IronScheme.Compiler
{   
    /// <summary>
    /// Summary Canonical example of GPLEX automaton
    /// </summary>
    
#if STANDALONE
    //
    // These are the dummy declarations for stand-alone GPLEX applications
    // normally these declarations would come from the parser.
    // If you declare /noparser, or %option noparser then you get this.
    //

    public enum Tokens
    { 
      EOF = 0, maxParseToken = int.MaxValue 
      // must have at least these two, values are almost arbitrary
    }

    public abstract class ScanBase
    {
        public abstract int yylex();
#if BABEL
        protected abstract int CurrentSc { get; set; }
        // EolState is the 32-bit of state data persisted at 
        // the end of each line for Visual Studio colorization.  
        // The default is to return CurrentSc.  You must override
        // this if you want more complicated behavior.
        public virtual int EolState { 
            get { return CurrentSc; }
            set { CurrentSc = value; } 
        }
    }
    
    public interface IColorScan
    {
        void SetSource(string source, int offset);
        int GetNext(ref int state, out int start, out int end);
#endif // BABEL
    }

#endif // STANDALONE

    public abstract class ScanBuff
    {
        public const int EOF = -1;
        public abstract int Pos { get; set; }
        public abstract int Read();
        public abstract int Peek();
        public abstract int ReadPos { get; }
        public abstract string GetString(int b, int e);
    }
    
    // If the compiler can't find ScanBase maybe you need to run
    // GPPG with the /gplex option, or GPLEX with /noparser
#if BABEL
    public sealed partial class Scanner : ScanBase, IColorScan
    {
        public ScanBuff buffer;
        int currentScOrd;  // start condition ordinal
        
        protected override int CurrentSc 
        {
             // The current start state is a property
             // to try to avoid the user error of setting
             // scState but forgetting to update the FSA
             // start state "currentStart"
             //
             get { return currentScOrd; }  // i.e. return YY_START;
             set { currentScOrd = value;   // i.e. BEGIN(value);
                   currentStart = startState[value]; }
        }
#else  // BABEL
    public sealed partial class Scanner : ScanBase
    {
        public ScanBuff buffer;
        int currentScOrd;  // start condition ordinal
#endif // BABEL
        
        private static int GetMaxParseToken() {
            System.Reflection.FieldInfo f = typeof(Tokens).GetField("maxParseToken");
            return (f == null ? int.MaxValue : (int)f.GetValue(null));
        }
        
        static int parserMax = GetMaxParseToken();
        
        enum Result {accept, noMatch, contextFound};

        const int maxAccept = 204;
        const int initial = 205;
        const int eofNum = 0;
        const int goStart = -1;
        const int INITIAL = 0;
        const int ML_COMMENT = 1;

/* ****************************************************************************
 * Copyright (c) Llewellyn Pritchard. 
 *
 * This source code is subject to terms and conditions of the Microsoft Public License. 
 * A copy of the license can be found in the License.html file at the root of this distribution. 
 * By using this source code in any fashion, you are agreeing to be bound by the terms of the 
 * Microsoft Public License.
 *
 * You must not remove this notice, or any other, from this software.
 * ***************************************************************************/
void FixLineNum(string text)
{
  if (text.EndsWith("\n") || text.EndsWith("\r"))
  {
    lNum--;
  }
}

public override void yyerror(string format, params object[] args)
{
  if (!format.Contains("EOF"))
  {
    Console.Error.WriteLine(format, args);
  }
}

public int MakeSymbol()
{
  string t = yytext;
  FixLineNum(t);
  t = t.Substring(0, t.Length - 1);
  yylval.text = t;
  yyless(t.Length);
  yylloc = new LexLocation(yyline,yycol,yyline,yycol + yyleng);
  return (int)Tokens.SYMBOL;
}

public int MakeBoolean()
{
  string t = yytext;
  FixLineNum(t);
  t = t.Substring(0, t.Length - 1);
  yylval.text = t;
  yyless(t.Length);
  yylloc = new LexLocation(yyline,yycol,yyline,yycol + yyleng);
  return (int)Tokens.LITERAL;
}

public int MakeNumber()
{
  string t = yytext;
  FixLineNum(t);
  t = t.Substring(0, t.Length - 1);
  yylval.text = t;
  yyless(t.Length);
  yylloc = new LexLocation(yyline,yycol,yyline,yycol + yyleng);
  return (int)Tokens.NUMBER;
}

public int MakeChar()
{
  string t = yytext;
  FixLineNum(t);
  t = t.Substring(0, t.Length - 1);
  yylval.text = Helper.ParseChar(t);
  yyless(t.Length);
  yylloc = new LexLocation(yyline,yycol,yyline,yycol + yyleng);
  return (int)Tokens.CHARACTER;
}


public int Make(Tokens token)
{
  yylval.text = yytext;
  yylloc = new LexLocation(yyline,yycol,yyline,yycol + yyleng);
  return (int)token;
}
        int state;
        int currentStart = initial;
        int chr;           // last character read
        int cNum = 0;      // ordinal number of chr
        int lNum = 0;      // current line number
        int lineStartNum;  // ordinal number at start of line
        //
        // The following instance variables are used, among other
        // things, for constructing the yylloc location objects.
        //
        int tokPos;        // buffer position at start of token
        int tokNum;        // ordinal number of first character
        int tokLen;        // number of characters in token
        int tokCol;        // zero-based column number at start of token
        int tokLin;        // line number at start of token
        int tokEPos;       // buffer position at end of token
        int tokECol;       // column number at end of token
        int tokELin;       // line number at end of token
        string tokTxt;     // lazily constructed text of token
#if STACK          
        private Stack<int> scStack = new Stack<int>();
#endif // STACK

#region ScannerTables
    struct Table {
        public int min; public int rng; public int dflt;
        public short[] nxt;
        public Table(int m, int x, int d, short[] n) {
            min = m; rng = x; dflt = d; nxt = n;
        }
    };

    static int[] startState = {205, 268, 0};

#region CharacterMap
    //
    // There are 61 equivalence classes
    // There are 2 character sequence regions
    // There are 1 tables, 127 entries
    // There are 1 runs, 0 singletons
    //
    static sbyte[] map0 = new sbyte[127] {
/* \0     */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 2, 0, 0, 3, 0, 0, 
/* \020   */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
/* \040   */ 1, 7, 35, 4, 60, 60, 60, 56, 53, 9, 60, 40, 57, 39, 43, 42, 
/* 0      */ 44, 41, 47, 47, 47, 47, 47, 47, 54, 13, 60, 6, 60, 60, 58, 60, 
/* @      */ 45, 14, 36, 14, 48, 38, 15, 59, 59, 37, 59, 59, 49, 59, 59, 46, 
/* P      */ 59, 59, 59, 49, 8, 59, 59, 59, 50, 59, 59, 51, 10, 52, 60, 60, 
/* `      */ 55, 19, 22, 23, 31, 27, 30, 34, 59, 29, 59, 24, 18, 21, 16, 46, 
/* p      */ 26, 59, 20, 25, 28, 17, 33, 32, 12, 59, 59, 0, 5, 0, 60 };

    sbyte Map(int chr)
    { // '\0' <= chr <= '\uFFFF'
      if (chr < 127) return map0[chr - 0];
      else return (sbyte)0;
    }
#endregion

    static Table[] NxS = new Table[269];

    static Scanner() {
    NxS[0] = new Table(0, 0, 0, null);    NxS[1] = new Table(0, 0, -1, null);    NxS[2] = new Table(1, 11, -1, new short[] {2, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, 2});
    NxS[3] = new Table(3, 1, -1, new short[] {4});
    NxS[4] = new Table(0, 0, -1, null);    NxS[5] = new Table(5, 53, -1, new short[] {100, 101, 6, 215, -1, 216, 
          -1, 217, -1, -1, 215, -1, -1, -1, -1, -1, -1, 218, -1, -1, -1, -1, 
          219, 215, 219, 215, 220, -1, 221, -1, -1, 218, 219, 219, -1, -1, -1, -1, 
          -1, -1, -1, 222, -1, 220, -1, 217, -1, -1, 102, -1, 103, 104, 105});
    NxS[6] = new Table(2, 1, 6, new short[] {-1});
    NxS[7] = new Table(35, 38, 94, new short[] {27, 94, 94, 94, 94, 94, 
          94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 95, 27, 27, 94, 63, 63, 
          63, 94, 94, 94, 63, 27, 28, 27, 27, 63, 27, 94, 94, 27, 63, 27});
    NxS[8] = new Table(0, 0, -1, null);    NxS[9] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 97, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 68, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 97, 88, 98, 97, 73, 68, 97, 70, 70, 68, 29, 29, 29, 97});
    NxS[10] = new Table(10, 26, 212, new short[] {213, 212, 212, 212, 212, 212, 
          212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 
          212, 212, 212, 96});
    NxS[11] = new Table(29, 49, 63, new short[] {66, 63, 63, 63, 63, 63, 
          27, 63, 63, 63, 63, 63, 64, 63, 67, 64, 63, 63, 64, 63, 63, 63, 
          27, 27, 27, 64, 63, 63, 63, 94, 63, 63, 63, 27, 28, 27, 27, 63, 
          27, 63, 63, 27, 63, 27, 63, 64, 63, 63, 65});
    NxS[12] = new Table(29, 49, 63, new short[] {66, 63, 63, 63, 63, 63, 
          27, 63, 63, 63, 63, 63, 64, 63, 67, 64, 63, 63, 64, 63, 63, 63, 
          27, 27, 27, 64, 63, 63, 63, 63, 63, 63, 63, 27, 28, 27, 27, 63, 
          27, 63, 63, 27, 63, 27, 63, 64, 63, 63, 65});
    NxS[13] = new Table(35, 40, 21, new short[] {22, 21, 21, 21, 21, 21, 
          24, 21, 25, 24, 21, 21, 24, 21, 21, 21, 22, 22, 22, 24, 21, 21, 
          21, 21, 21, 21, 21, 22, 23, 22, 22, 21, 22, 21, 21, 22, 21, 22, 
          21, 24});
    NxS[14] = new Table(0, 0, -1, null);    NxS[15] = new Table(0, 0, -1, null);    NxS[16] = new Table(0, 0, -1, null);    NxS[17] = new Table(0, 0, -1, null);    NxS[18] = new Table(0, 0, -1, null);    NxS[19] = new Table(45, 1, -1, new short[] {20});
    NxS[20] = new Table(0, 0, -1, null);    NxS[21] = new Table(35, 38, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1});
    NxS[22] = new Table(0, 0, -1, null);    NxS[23] = new Table(3, 1, -1, new short[] {22});
    NxS[24] = new Table(1, 54, 21, new short[] {29, 30, 29, 29, 21, 29, 
          21, 21, 29, 21, 29, 21, 24, 21, 31, 21, 21, 31, 21, 21, 21, 21, 
          21, 21, 31, 21, 31, 21, 21, 31, 31, 21, 21, 21, 29, 21, 21, 31, 
          32, 32, 24, 21, 21, 24, 33, 21, 24, 31, 31, 21, 29, 29, 29, 24});
    NxS[25] = new Table(35, 38, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 26, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1});
    NxS[26] = new Table(35, 38, 21, new short[] {27, 21, 21, 21, 21, 21, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 27, 27, 27, 21, 21, 21, 
          21, 21, 21, 21, 21, 27, 28, 27, 27, 21, 27, 21, 21, 27, 21, 27});
    NxS[27] = new Table(0, 0, -1, null);    NxS[28] = new Table(3, 1, -1, new short[] {27});
    NxS[29] = new Table(0, 0, -1, null);    NxS[30] = new Table(3, 1, -1, new short[] {29});
    NxS[31] = new Table(35, 40, 21, new short[] {-1, 21, 21, 21, 62, 62, 
          61, 21, 21, 61, 21, 21, 61, 21, 21, 21, -1, -1, -1, 61, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 61});
    NxS[32] = new Table(29, 49, 21, new short[] {50, 21, 21, 21, 21, 21, 
          -1, 21, 21, 21, 21, 21, 48, 21, 51, 48, 21, 21, 48, 21, 21, 21, 
          -1, -1, -1, 48, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, -1, 21, 
          -1, 21, 21, -1, 21, -1, 21, 48, 21, 21, 49});
    NxS[33] = new Table(35, 40, 21, new short[] {-1, 21, 21, 21, 35, 35, 
          34, 21, 36, 34, 21, 21, 34, 21, 21, 21, -1, -1, -1, 34, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 34});
    NxS[34] = new Table(1, 54, 21, new short[] {29, 30, 29, 29, 21, 29, 
          21, 21, 29, 21, 29, 21, 34, 21, 38, 21, 21, 38, 21, 21, 21, 21, 
          21, 21, 38, 21, 38, 21, 21, 38, 38, 21, 21, 21, 29, 21, 21, 38, 
          21, 21, 34, 40, 37, 34, 21, 21, 34, 38, 38, 21, 29, 29, 29, 34});
    NxS[35] = new Table(29, 49, 21, new short[] {42, 21, 21, 21, 21, 21, 
          -1, 21, 21, 21, 21, 21, 34, 21, 36, 34, 21, 21, 34, 21, 21, 21, 
          -1, -1, -1, 34, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, -1, 21, 
          -1, 21, 21, -1, 21, -1, 21, 34, 21, 21, 41});
    NxS[36] = new Table(35, 40, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          37, 21, 21, 37, 21, 21, 37, 21, 21, 21, -1, -1, -1, 37, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 37});
    NxS[37] = new Table(1, 54, 21, new short[] {29, 30, 29, 29, 21, 29, 
          21, 21, 29, 21, 29, 21, 37, 21, 38, 21, 21, 38, 21, 21, 21, 21, 
          21, 21, 38, 21, 38, 21, 21, 38, 38, 21, 21, 21, 29, 21, 21, 38, 
          21, 21, 37, 21, 21, 37, 21, 21, 37, 38, 38, 21, 29, 29, 29, 37});
    NxS[38] = new Table(35, 40, 21, new short[] {-1, 21, 21, 21, 40, 40, 
          39, 21, 21, 39, 21, 21, 39, 21, 21, 21, -1, -1, -1, 39, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 39});
    NxS[39] = new Table(35, 40, 21, new short[] {29, 21, 21, 21, 21, 21, 
          39, 21, 21, 39, 21, 21, 39, 21, 21, 21, 29, 29, 29, 39, 21, 21, 
          21, 21, 21, 21, 21, 29, 30, 29, 29, 21, 29, 21, 21, 29, 21, 29, 
          21, 39});
    NxS[40] = new Table(35, 40, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          39, 21, 21, 39, 21, 21, 39, 21, 21, 21, -1, -1, -1, 39, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 39});
    NxS[41] = new Table(35, 46, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 21, 21, 21, 21, 21, 21, 47});
    NxS[42] = new Table(35, 43, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 21, 21, 21, 43});
    NxS[43] = new Table(30, 43, 21, new short[] {44, 21, 21, 21, 21, -1, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, 
          -1, -1, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 
          21, 21, -1, 21, -1});
    NxS[44] = new Table(35, 38, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 45, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1});
    NxS[45] = new Table(35, 38, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 21, 46, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1});
    NxS[46] = new Table(35, 38, 21, new short[] {29, 21, 21, 21, 21, 21, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 29, 29, 29, 21, 21, 21, 
          21, 21, 21, 21, 21, 29, 30, 29, 29, 21, 29, 21, 21, 29, 21, 29});
    NxS[47] = new Table(35, 43, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 21, 21, 21, 44});
    NxS[48] = new Table(1, 54, 21, new short[] {-1, -1, -1, -1, 21, -1, 
          21, 21, -1, 21, -1, 21, 48, 21, 53, 21, 21, 53, 21, 21, 21, 21, 
          21, 21, 53, 21, 53, 21, 46, 53, 53, 21, 21, 21, -1, 21, 21, 53, 
          21, 21, 48, 55, 52, 48, 21, 21, 48, 53, 53, 21, -1, -1, -1, 48});
    NxS[49] = new Table(35, 46, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 21, 21, 21, 21, 21, 21, 60});
    NxS[50] = new Table(35, 43, 21, new short[] {29, 21, 21, 21, 21, 21, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 29, 29, 29, 21, 21, 21, 
          21, 21, 21, 21, 21, 29, 30, 29, 29, 21, 29, 21, 21, 29, 21, 29, 
          21, 21, 21, 21, 56});
    NxS[51] = new Table(35, 40, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          52, 21, 21, 52, 21, 21, 52, 21, 21, 21, -1, -1, -1, 52, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 52});
    NxS[52] = new Table(1, 54, 21, new short[] {-1, -1, -1, -1, 21, -1, 
          21, 21, -1, 21, -1, 21, 52, 21, 53, 21, 21, 53, 21, 21, 21, 21, 
          21, 21, 53, 21, 53, 21, 46, 53, 53, 21, 21, 21, -1, 21, 21, 53, 
          21, 21, 52, 21, 21, 52, 21, 21, 52, 53, 53, 21, -1, -1, -1, 52});
    NxS[53] = new Table(35, 40, 21, new short[] {-1, 21, 21, 21, 55, 55, 
          54, 21, 21, 54, 21, 21, 54, 21, 21, 21, -1, -1, -1, 54, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 54});
    NxS[54] = new Table(29, 46, 21, new short[] {46, 21, 21, 21, 21, 21, 
          -1, 21, 21, 21, 21, 21, 54, 21, 21, 54, 21, 21, 54, 21, 21, 21, 
          -1, -1, -1, 54, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, -1, 21, 
          -1, 21, 21, -1, 21, -1, 21, 54});
    NxS[55] = new Table(35, 40, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          54, 21, 21, 54, 21, 21, 54, 21, 21, 21, -1, -1, -1, 54, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 54});
    NxS[56] = new Table(30, 43, 21, new short[] {57, 21, 21, 21, 21, -1, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, 
          -1, -1, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 
          21, 21, -1, 21, -1});
    NxS[57] = new Table(35, 38, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 58, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1});
    NxS[58] = new Table(35, 38, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 21, 59, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1});
    NxS[59] = new Table(29, 44, 21, new short[] {46, 21, 21, 21, 21, 21, 
          -1, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 
          -1, -1, -1, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, -1, 21, 
          -1, 21, 21, -1, 21, -1});
    NxS[60] = new Table(35, 43, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          21, 21, 21, 21, 21, 21, 21, 21, 21, 21, -1, -1, -1, 21, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 21, 21, 21, 57});
    NxS[61] = new Table(35, 40, 21, new short[] {29, 21, 21, 21, 32, 32, 
          61, 21, 21, 61, 33, 21, 61, 21, 21, 21, 29, 29, 29, 61, 21, 21, 
          21, 21, 21, 21, 21, 29, 30, 29, 29, 21, 29, 21, 21, 29, 21, 29, 
          21, 61});
    NxS[62] = new Table(35, 40, 21, new short[] {-1, 21, 21, 21, 21, 21, 
          61, 21, 21, 61, 21, 21, 61, 21, 21, 21, -1, -1, -1, 61, 21, 21, 
          21, 21, 21, 21, 21, -1, -1, -1, -1, 21, -1, 21, 21, -1, 21, -1, 
          21, 61});
    NxS[63] = new Table(0, 0, -1, null);    NxS[64] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 93, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 71, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 93, 88, 69, 93, 73, 68, 93, 70, 70, 68, 29, 29, 29, 93});
    NxS[65] = new Table(19, 1, -1, new short[] {207});
    NxS[66] = new Table(35, 43, 68, new short[] {29, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29, 
          68, 68, 68, 68, 89});
    NxS[67] = new Table(41, 34, -1, new short[] {206, -1, -1, 206, -1, -1, 
          206, -1, -1, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206});
    NxS[68] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[69] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 69, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 71, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 69, 68, 68, 69, 73, 68, 69, 70, 70, 68, 29, 29, 29, 69});
    NxS[70] = new Table(35, 40, 68, new short[] {-1, 68, 68, 68, 88, 88, 
          87, 68, 68, 87, 68, 68, 87, 68, 68, 68, -1, -1, -1, 87, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1, 
          68, 87});
    NxS[71] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[72] = new Table(29, 46, 68, new short[] {71, 68, 68, 68, 68, 68, 
          -1, 68, 68, 68, 68, 68, 72, 68, 68, 72, 68, 68, 72, 68, 68, 68, 
          -1, -1, -1, 72, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, 68, 
          -1, 68, 68, -1, 68, -1, 68, 72});
    NxS[73] = new Table(35, 40, 68, new short[] {-1, 68, 68, 68, 75, 75, 
          74, 68, 76, 74, 68, 68, 74, 68, 68, 68, -1, -1, -1, 74, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1, 
          68, 74});
    NxS[74] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 74, 68, 78, 68, 68, 78, 68, 68, 68, 68, 
          68, 68, 78, 68, 78, 68, 68, 78, 78, 68, 68, 68, 29, 68, 68, 78, 
          68, 68, 74, 80, 77, 74, 68, 68, 74, 78, 78, 68, 29, 29, 29, 74});
    NxS[75] = new Table(29, 49, 68, new short[] {82, 68, 68, 68, 68, 68, 
          -1, 68, 68, 68, 68, 68, 74, 68, 76, 74, 68, 68, 74, 68, 68, 68, 
          -1, -1, -1, 74, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, 68, 
          -1, 68, 68, -1, 68, -1, 68, 74, 68, 68, 81});
    NxS[76] = new Table(35, 40, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          77, 68, 68, 77, 68, 68, 77, 68, 68, 68, -1, -1, -1, 77, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1, 
          68, 77});
    NxS[77] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 77, 68, 78, 68, 68, 78, 68, 68, 68, 68, 
          68, 68, 78, 68, 78, 68, 68, 78, 78, 68, 68, 68, 29, 68, 68, 78, 
          68, 68, 77, 68, 68, 77, 68, 68, 77, 78, 78, 68, 29, 29, 29, 77});
    NxS[78] = new Table(35, 40, 68, new short[] {-1, 68, 68, 68, 80, 80, 
          79, 68, 68, 79, 68, 68, 79, 68, 68, 68, -1, -1, -1, 79, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1, 
          68, 79});
    NxS[79] = new Table(35, 40, 68, new short[] {29, 68, 68, 68, 68, 68, 
          79, 68, 68, 79, 68, 68, 79, 68, 68, 68, 29, 29, 29, 79, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29, 
          68, 79});
    NxS[80] = new Table(35, 40, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          79, 68, 68, 79, 68, 68, 79, 68, 68, 68, -1, -1, -1, 79, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1, 
          68, 79});
    NxS[81] = new Table(35, 46, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1, 
          68, 68, 68, 68, 68, 68, 68, 86});
    NxS[82] = new Table(35, 43, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1, 
          68, 68, 68, 68, 83});
    NxS[83] = new Table(30, 43, 68, new short[] {84, 68, 68, 68, 68, -1, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, 
          -1, -1, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 
          68, 68, -1, 68, -1});
    NxS[84] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 85, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[85] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 68, 71, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[86] = new Table(35, 43, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1, 
          68, 68, 68, 68, 84});
    NxS[87] = new Table(29, 46, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 87, 68, 68, 87, 73, 68, 87, 68, 68, 68, 
          29, 29, 29, 87, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29, 68, 87});
    NxS[88] = new Table(35, 40, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          87, 68, 68, 87, 68, 68, 87, 68, 68, 68, -1, -1, -1, 87, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1, 
          68, 87});
    NxS[89] = new Table(30, 43, 68, new short[] {90, 68, 68, 68, 68, -1, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, 
          -1, -1, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 
          68, 68, -1, 68, -1});
    NxS[90] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 91, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[91] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 68, 92, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[92] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 68, 68, 68, 68, 73, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[93] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 93, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 71, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 93, 88, 69, 93, 73, 68, 93, 70, 70, 68, 29, 29, 29, 93});
    NxS[94] = new Table(35, 38, 94, new short[] {27, 94, 94, 94, 94, 94, 
          94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 95, 27, 27, 94, 63, 63, 
          63, 94, 94, 94, 63, 27, 28, 27, 27, 63, 27, 94, 94, 27, 63, 27});
    NxS[95] = new Table(52, 1, -1, new short[] {211});
    NxS[96] = new Table(0, 0, -1, null);    NxS[97] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 97, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 68, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 97, 88, 98, 97, 73, 68, 97, 70, 70, 68, 29, 29, 29, 97});
    NxS[98] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 98, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 68, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 98, 68, 68, 98, 73, 68, 98, 70, 70, 68, 29, 29, 29, 98});
    NxS[99] = new Table(35, 40, 68, new short[] {29, 68, 68, 68, 72, 72, 
          99, 68, 68, 99, 73, 68, 99, 68, 68, 68, 29, 29, 29, 99, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29, 
          68, 99});
    NxS[100] = new Table(0, 0, -1, null);    NxS[101] = new Table(0, 0, -1, null);    NxS[102] = new Table(0, 0, -1, null);    NxS[103] = new Table(0, 0, -1, null);    NxS[104] = new Table(0, 0, -1, null);    NxS[105] = new Table(45, 1, -1, new short[] {106});
    NxS[106] = new Table(0, 0, -1, null);    NxS[107] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 72, 72, 
          107, 111, 68, 107, 108, 68, 107, 68, 68, 68, 29, 29, 29, 107, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[108] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 109, 109, 
          110, 68, 68, 110, 68, 68, 110, 68, 68, 68, -1, -1, -1, 110, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[109] = new Table(29, 49, 68, new short[] {82, 68, 68, 68, 68, 68, 
          -1, 68, 68, 68, 68, 68, 110, 68, 68, 110, 68, 68, 110, 68, 68, 68, 
          -1, -1, -1, 110, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, 68, 
          -1, 68, 68, -1, 68, -1, 68, 68, 68, 68, 81});
    NxS[110] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 68, 68, 
          110, 111, 68, 110, 68, 68, 110, 68, 68, 68, 29, 29, 29, 110, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[111] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          112, 68, 68, 112, 68, 68, 112, 68, 68, 68, -1, -1, -1, 112, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[112] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 68, 68, 
          112, 68, 68, 112, 68, 68, 112, 68, 68, 68, 29, 29, 29, 112, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[113] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 72, 72, 
          113, 68, 68, 113, 108, 68, 113, 68, 68, 68, 29, 29, 29, 113, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[114] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 114, 115, 68, 114, 108, 68, 114, 68, 68, 68, 
          29, 29, 29, 114, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[115] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          116, 68, 68, 116, 68, 68, 116, 68, 68, 68, -1, -1, -1, 116, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[116] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 116, 68, 68, 116, 108, 68, 116, 68, 68, 68, 
          29, 29, 29, 116, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[117] = new Table(30, 43, 68, new short[] {118, 68, 68, 68, 68, -1, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, 
          -1, -1, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 
          68, 68, -1, 68, -1});
    NxS[118] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 119, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[119] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 68, 120, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[120] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 68, 68, 68, 68, 108, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[121] = new Table(0, 0, -1, null);    NxS[122] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 72, 72, 
          122, 123, 68, 122, 124, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[123] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          129, 68, 68, 129, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[124] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 125, 125, 
          126, 68, 68, 126, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[125] = new Table(29, 49, 68, new short[] {82, 68, 68, 68, 68, 68, 
          -1, 68, 68, 68, 68, 68, 126, 68, 68, 126, 68, 68, 68, 68, 68, 68, 
          -1, -1, -1, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, 68, 
          -1, 68, 68, -1, 68, -1, 68, 68, 68, 68, 81});
    NxS[126] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 68, 68, 
          126, 127, 68, 126, 68, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[127] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          128, 68, 68, 128, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[128] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 68, 68, 
          128, 68, 68, 128, 68, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[129] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 72, 72, 
          129, 68, 68, 129, 124, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[130] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 130, 123, 68, 130, 124, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[131] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 131, 68, 68, 131, 124, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[132] = new Table(30, 43, 68, new short[] {133, 68, 68, 68, 68, -1, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, 
          -1, -1, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 
          68, 68, -1, 68, -1});
    NxS[133] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 134, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[134] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 68, 135, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[135] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 68, 68, 68, 68, 124, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[136] = new Table(30, 43, 68, new short[] {137, 68, 68, 68, 68, -1, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, 
          -1, -1, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 
          68, 68, -1, 68, -1});
    NxS[137] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 138, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[138] = new Table(35, 38, 68, new short[] {-1, 68, 68, 68, 68, 68, 
          68, 68, 68, 139, 68, 68, 68, 68, 68, 68, -1, -1, -1, 68, 68, 68, 
          68, 68, 68, 68, 68, -1, -1, -1, -1, 68, -1, 68, 68, -1, 68, -1});
    NxS[139] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 68, 68, 68, 68, 140, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[140] = new Table(1, 54, 68, new short[] {-1, -1, -1, -1, 68, -1, 
          68, 68, -1, 68, -1, 68, 141, 141, 141, 68, 68, 68, 141, 68, 68, 141, 
          141, 68, 68, 68, 141, 68, 68, 141, 141, 68, 68, 68, -1, 141, 68, 141, 
          142, 142, 141, 68, 68, 141, 68, 68, 141, 141, 68, 68, -1, -1, -1, 141});
    NxS[141] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 141, 141, 141, 68, 68, 68, 141, 68, 68, 141, 
          141, 68, 68, 68, 141, 68, 68, 141, 141, 68, 68, 68, 29, 141, 68, 141, 
          68, 68, 141, 143, 68, 141, 68, 68, 141, 141, 68, 68, 29, 29, 29, 141});
    NxS[142] = new Table(1, 54, 68, new short[] {-1, -1, -1, -1, 68, -1, 
          68, 68, -1, 68, -1, 68, 141, 141, 141, 81, 68, 68, 141, 68, 68, 141, 
          141, 68, 68, 68, 141, 68, 82, 141, 141, 68, 68, 68, -1, 141, 68, 141, 
          68, 68, 141, 68, 68, 141, 68, 68, 141, 141, 68, 68, -1, -1, -1, 141});
    NxS[143] = new Table(1, 54, 68, new short[] {-1, -1, -1, -1, 68, -1, 
          68, 68, -1, 68, -1, 68, 144, 144, 144, 68, 68, 68, 144, 68, 68, 144, 
          144, 68, 68, 68, 144, 68, 68, 144, 144, 68, 68, 68, -1, 144, 68, 144, 
          68, 68, 144, 68, 68, 144, 68, 68, 144, 144, 68, 68, -1, -1, -1, 144});
    NxS[144] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 144, 144, 144, 68, 68, 68, 144, 68, 68, 144, 
          144, 68, 68, 68, 144, 68, 68, 144, 144, 68, 68, 68, 29, 144, 68, 144, 
          68, 68, 144, 68, 68, 144, 68, 68, 144, 144, 68, 68, 29, 29, 29, 144});
    NxS[145] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 145, 145, 145, 68, 68, 68, 145, 68, 68, 145, 
          145, 68, 68, 68, 145, 68, 71, 145, 145, 68, 68, 68, 29, 145, 68, 145, 
          72, 72, 145, 146, 68, 145, 140, 68, 145, 145, 68, 68, 29, 29, 29, 145});
    NxS[146] = new Table(1, 54, 68, new short[] {-1, -1, -1, -1, 68, -1, 
          68, 68, -1, 68, -1, 68, 147, 147, 147, 68, 68, 68, 147, 68, 68, 147, 
          147, 68, 68, 68, 147, 68, 68, 147, 147, 68, 68, 68, -1, 147, 68, 147, 
          68, 68, 147, 68, 68, 147, 68, 68, 147, 147, 68, 68, -1, -1, -1, 147});
    NxS[147] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 147, 147, 147, 68, 68, 68, 147, 68, 68, 147, 
          147, 68, 68, 68, 147, 68, 71, 147, 147, 68, 68, 68, 29, 147, 68, 147, 
          72, 72, 147, 68, 68, 147, 140, 68, 147, 147, 68, 68, 29, 29, 29, 147});
    NxS[148] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 148, 148, 148, 68, 68, 68, 148, 68, 68, 148, 
          148, 68, 68, 68, 148, 68, 68, 148, 148, 68, 68, 68, 29, 148, 68, 148, 
          72, 72, 148, 143, 68, 148, 140, 68, 148, 148, 68, 68, 29, 29, 29, 148});
    NxS[149] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 149, 149, 149, 68, 68, 68, 149, 68, 68, 149, 
          149, 68, 68, 68, 149, 68, 68, 149, 149, 68, 68, 68, 29, 149, 68, 149, 
          72, 72, 149, 68, 68, 149, 140, 68, 149, 149, 68, 68, 29, 29, 29, 149});
    NxS[150] = new Table(35, 38, 166, new short[] {151, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 151, 151, 151, 166, 166, 166, 
          166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 151, 166, 166, 151, 166, 151});
    NxS[151] = new Table(0, 0, -1, null);    NxS[152] = new Table(3, 1, -1, new short[] {151});
    NxS[153] = new Table(35, 38, 166, new short[] {151, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 151, 151, 151, 166, 166, 166, 
          166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 151, 166, 166, 151, 166, 151});
    NxS[154] = new Table(1, 54, 166, new short[] {151, 152, 151, 151, 166, 151, 
          166, 166, 151, 166, 151, 166, 154, 154, 154, 166, 166, 166, 154, 166, 166, 154, 
          154, 166, 166, 166, 154, 166, 166, 154, 154, 166, 166, 166, 151, 154, 166, 154, 
          166, 166, 154, 166, 166, 154, 166, 166, 154, 154, 166, 166, 151, 151, 151, 154});
    NxS[155] = new Table(51, 46, 166, new short[] {151, 151, 151, 166, 166, 166, 
          166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 151, 166, 166, 151, 166, 151, 
          166, 166, 166, 166, 166, 194, 166, 166, 166, 166, 166, 166, 166, 166, 166, 195, 
          166, 166, 166, 166, 166, 166, 166, 151});
    NxS[156] = new Table(29, 44, 166, new short[] {188, 166, 166, 166, 166, 166, 
          151, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          151, 151, 151, 166, 166, 166, 166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 
          151, 166, 166, 151, 166, 151});
    NxS[157] = new Table(35, 45, 166, new short[] {151, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 151, 151, 151, 166, 166, 166, 
          166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 151, 166, 166, 151, 166, 151, 
          166, 166, 166, 166, 166, 166, 185});
    NxS[158] = new Table(27, 46, 166, new short[] {181, 166, 166, 166, 166, 166, 
          166, 166, 151, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, 166, 151, 151, 151, 166, 166, 166, 166, 166, 166, 166, 166, 151, 152, 151, 
          151, 166, 151, 166, 166, 151, 166, 151});
    NxS[159] = new Table(35, 46, 166, new short[] {151, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 151, 151, 151, 166, 166, 166, 
          166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 151, 166, 166, 151, 166, 151, 
          166, 166, 166, 166, 166, 166, 166, 177});
    NxS[160] = new Table(51, 46, 166, new short[] {151, 151, 151, 166, 166, 166, 
          166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 151, 166, 166, 151, 166, 151, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 175, 166, 
          166, 166, 166, 166, 166, 166, 166, 151});
    NxS[161] = new Table(35, 46, 166, new short[] {151, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 151, 151, 151, 166, 166, 166, 
          166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 151, 166, 166, 151, 166, 151, 
          166, 166, 166, 166, 166, 166, 166, 174});
    NxS[162] = new Table(51, 46, 166, new short[] {151, 151, 151, 166, 166, 166, 
          166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 151, 166, 166, 151, 166, 151, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 173, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 151});
    NxS[163] = new Table(35, 46, 166, new short[] {151, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 151, 151, 151, 166, 166, 166, 
          166, 166, 166, 166, 166, 151, 152, 151, 151, 166, 151, 166, 166, 151, 166, 151, 
          166, 166, 166, 166, 166, 166, 166, 168});
    NxS[164] = new Table(27, 46, 166, new short[] {169, 166, 166, 166, 166, 166, 
          166, 166, 151, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, 166, 151, 151, 151, 166, 166, 166, 166, 166, 166, 166, 166, 151, 152, 151, 
          151, 166, 151, 166, 166, 151, 166, 151});
    NxS[165] = new Table(28, 45, 166, new short[] {167, 166, 166, 166, 166, 166, 
          166, 151, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, 151, 151, 151, 166, 166, 166, 166, 166, 166, 166, 166, 151, 152, 151, 151, 
          166, 151, 166, 166, 151, 166, 151});
    NxS[166] = new Table(35, 38, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1});
    NxS[167] = new Table(35, 46, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 168});
    NxS[168] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 150, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[169] = new Table(35, 45, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 170});
    NxS[170] = new Table(27, 46, 166, new short[] {171, 166, 166, 166, 166, 166, 
          166, 166, -1, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, 166, -1, -1, -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 
          -1, 166, -1, 166, 166, -1, 166, -1});
    NxS[171] = new Table(28, 45, 166, new short[] {172, 166, 166, 166, 166, 166, 
          166, -1, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, -1, -1, -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, -1, 
          166, -1, 166, 166, -1, 166, -1});
    NxS[172] = new Table(27, 46, 166, new short[] {150, 166, 166, 166, 166, 166, 
          166, 166, -1, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, 166, -1, -1, -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 
          -1, 166, -1, 166, 166, -1, 166, -1});
    NxS[173] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 150, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[174] = new Table(34, 39, 166, new short[] {172, -1, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 
          166, 166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, 
          -1});
    NxS[175] = new Table(35, 46, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 176});
    NxS[176] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 172, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[177] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 178, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[178] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 179, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[179] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 180, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[180] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 175, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[181] = new Table(28, 45, 166, new short[] {182, 166, 166, 166, 166, 166, 
          166, -1, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, -1, -1, -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, -1, 
          166, -1, 166, 166, -1, 166, -1});
    NxS[182] = new Table(35, 44, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 183});
    NxS[183] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 184, 166, 166, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[184] = new Table(35, 43, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 150});
    NxS[185] = new Table(35, 46, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 186});
    NxS[186] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 187, 166, 166, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[187] = new Table(51, 46, 166, new short[] {-1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 150, 166, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, -1});
    NxS[188] = new Table(35, 43, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 189});
    NxS[189] = new Table(27, 46, 166, new short[] {190, 166, 166, 166, 166, 166, 
          166, 166, -1, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, 166, -1, -1, -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 
          -1, 166, -1, 166, 166, -1, 166, -1});
    NxS[190] = new Table(30, 43, 166, new short[] {191, 166, 166, 166, 166, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, 
          -1, -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 
          166, 166, -1, 166, -1});
    NxS[191] = new Table(27, 46, 166, new short[] {192, 166, 166, 166, 166, 166, 
          166, 166, -1, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, 166, -1, -1, -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 
          -1, 166, -1, 166, 166, -1, 166, -1});
    NxS[192] = new Table(27, 46, 166, new short[] {193, 166, 166, 166, 166, 166, 
          166, 166, -1, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          166, 166, -1, -1, -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 
          -1, 166, -1, 166, 166, -1, 166, -1});
    NxS[193] = new Table(31, 42, 166, new short[] {150, 166, 166, 166, -1, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, 
          -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 
          166, -1, 166, -1});
    NxS[194] = new Table(35, 45, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 150});
    NxS[195] = new Table(32, 41, 166, new short[] {196, 166, 166, -1, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 
          166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, 
          -1, 166, -1});
    NxS[196] = new Table(35, 45, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 166, 166, 197});
    NxS[197] = new Table(29, 44, 166, new short[] {198, 166, 166, 166, 166, 166, 
          -1, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 
          -1, -1, -1, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, -1, 166, 
          -1, 166, 166, -1, 166, -1});
    NxS[198] = new Table(35, 43, 166, new short[] {-1, 166, 166, 166, 166, 166, 
          166, 166, 166, 166, 166, 166, 166, 166, 166, 166, -1, -1, -1, 166, 166, 166, 
          166, 166, 166, 166, 166, -1, -1, -1, -1, 166, -1, 166, 166, -1, 166, -1, 
          166, 166, 166, 166, 172});
    NxS[199] = new Table(35, 38, 199, new short[] {-1, 199, 199, 199, 199, 199, 
          199, 199, 199, 199, 199, 199, 199, 199, 199, 199, -1, -1, -1, 199, 199, 199, 
          199, 199, 199, 199, 199, -1, -1, -1, -1, 199, -1, 199, 199, -1, 199, -1});
    NxS[200] = new Table(0, 0, -1, null);    NxS[201] = new Table(3, 1, -1, new short[] {200});
    NxS[202] = new Table(2, 4, 202, new short[] {-1, 202, 202, -1});
    NxS[203] = new Table(4, 1, -1, new short[] {204});
    NxS[204] = new Table(0, 0, -1, null);    NxS[205] = new Table(35, 40, 7, new short[] {10, 7, 7, 7, 11, 12, 
          9, 7, 13, 9, 1, 7, 9, 7, 7, 7, 14, 15, 16, 9, 17, 18, 
          19, 7, 7, 7, 1, 2, 3, 4, 5, 1, 6, 7, 7, 8, 1, 2, 
          7, 9});
    NxS[206] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 69, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 71, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 69, 68, 68, 69, 73, 68, 69, 70, 70, 68, 29, 29, 29, 69});
    NxS[207] = new Table(16, 1, -1, new short[] {208});
    NxS[208] = new Table(43, 1, -1, new short[] {209});
    NxS[209] = new Table(44, 1, -1, new short[] {210});
    NxS[210] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 68, 68, 68, 68, 73, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[211] = new Table(35, 38, 94, new short[] {27, 94, 94, 94, 94, 94, 
          94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 95, 27, 27, 94, 63, 63, 
          63, 94, 94, 94, 63, 27, 28, 27, 27, 63, 27, 94, 94, 27, 63, 27});
    NxS[212] = new Table(10, 26, 212, new short[] {213, 212, 212, 212, 212, 212, 
          212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 212, 
          212, 212, 212, 96});
    NxS[213] = new Table(2, 34, -1, new short[] {212, 212, -1, -1, -1, -1, 
          -1, -1, 212, -1, 214, -1, -1, -1, 212, -1, -1, 212, 212, -1, 212, -1, 
          -1, -1, -1, -1, 212, -1, 212, -1, -1, 212, -1, 212});
    NxS[214] = new Table(13, 42, -1, new short[] {212, 212, 212, -1, -1, -1, 
          212, -1, -1, 212, 212, -1, -1, -1, 212, -1, -1, 212, 212, -1, -1, -1, 
          -1, 212, -1, 212, -1, -1, 212, -1, -1, 212, -1, -1, 212, 212, -1, -1, 
          -1, -1, -1, 212});
    NxS[215] = new Table(35, 38, 199, new short[] {200, 199, 199, 199, 199, 199, 
          199, 199, 199, 199, 199, 199, 199, 199, 199, 199, 200, 200, 200, 199, 199, 199, 
          199, 199, 199, 199, 199, 200, 201, 200, 200, 199, 200, 199, 199, 200, 199, 200});
    NxS[216] = new Table(51, 46, 150, new short[] {153, 153, 153, 150, 150, 150, 
          150, 150, 150, 150, 150, 151, 152, 153, 153, 150, 153, 150, 150, 153, 150, 153, 
          154, 150, 150, 150, 155, 150, 156, 157, 158, 150, 159, 150, 150, 160, 161, 162, 
          163, 150, 150, 164, 150, 165, 150, 153});
    NxS[217] = new Table(4, 51, -1, new short[] {267, -1, -1, -1, -1, -1, 
          -1, -1, -1, 257, 257, 257, -1, -1, -1, 257, -1, -1, 257, 257, -1, -1, 
          -1, 257, -1, -1, 257, 257, -1, -1, -1, -1, 257, -1, 257, 258, 258, 257, 
          -1, -1, 257, -1, -1, 257, 257, -1, -1, -1, -1, -1, 257});
    NxS[218] = new Table(39, 27, -1, new short[] {248, 248, 249, -1, -1, 249, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, 266});
    NxS[219] = new Table(39, 36, -1, new short[] {238, 238, 237, -1, 243, 237, 
          -1, -1, 237, -1, -1, -1, -1, -1, -1, 237, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, 245, -1, -1, -1, -1, -1, -1, -1, -1, 237});
    NxS[220] = new Table(39, 36, -1, new short[] {238, 238, 237, -1, 243, 237, 
          -1, -1, 237, -1, -1, -1, -1, -1, -1, 237, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, 236, -1, -1, -1, -1, -1, -1, -1, -1, 237});
    NxS[221] = new Table(17, 1, -1, new short[] {234});
    NxS[222] = new Table(39, 27, -1, new short[] {224, 224, 225, -1, -1, 225, 
          -1, -1, 225, -1, -1, -1, -1, -1, -1, 225, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, 223});
    NxS[223] = new Table(27, 12, -1, new short[] {233, -1, 233, -1, -1, -1, 
          -1, -1, -1, -1, 233, 233});
    NxS[224] = new Table(16, 39, -1, new short[] {226, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, 227, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, 228, -1, -1, 228, -1, -1, 228, -1, -1, -1, -1, -1, -1, 
          228});
    NxS[225] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 72, 72, 
          107, 111, 68, 107, 108, 68, 107, 68, 68, 68, 29, 29, 29, 107, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[226] = new Table(19, 1, -1, new short[] {229});
    NxS[227] = new Table(35, 43, 68, new short[] {29, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29, 
          68, 68, 68, 68, 117});
    NxS[228] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 114, 115, 68, 114, 108, 68, 114, 68, 68, 68, 
          29, 29, 29, 114, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[229] = new Table(16, 1, -1, new short[] {230});
    NxS[230] = new Table(43, 1, -1, new short[] {231});
    NxS[231] = new Table(44, 1, -1, new short[] {232});
    NxS[232] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 68, 68, 68, 68, 108, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[233] = new Table(39, 16, -1, new short[] {224, 224, 225, -1, -1, 225, 
          -1, -1, 225, -1, -1, -1, -1, -1, -1, 225});
    NxS[234] = new Table(54, 1, -1, new short[] {235});
    NxS[235] = new Table(53, 1, -1, new short[] {121});
    NxS[236] = new Table(27, 12, -1, new short[] {244, -1, 244, -1, -1, -1, 
          -1, -1, -1, -1, 244, 244});
    NxS[237] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 97, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 68, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 97, 88, 98, 97, 73, 68, 97, 70, 70, 68, 29, 29, 29, 97});
    NxS[238] = new Table(13, 42, -1, new short[] {240, -1, -1, 241, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 242, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, 240, -1, 243, 240, -1, -1, 240, -1, -1, -1, 
          -1, -1, -1, 240});
    NxS[239] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 98, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 68, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 98, 68, 68, 98, 73, 68, 98, 70, 70, 68, 29, 29, 29, 98});
    NxS[240] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 93, 68, 70, 68, 68, 70, 68, 68, 68, 68, 
          68, 68, 70, 68, 70, 68, 71, 70, 70, 68, 68, 68, 29, 68, 68, 70, 
          72, 72, 93, 88, 69, 93, 73, 68, 93, 70, 70, 68, 29, 29, 29, 93});
    NxS[241] = new Table(19, 1, -1, new short[] {207});
    NxS[242] = new Table(35, 43, 68, new short[] {29, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29, 
          68, 68, 68, 68, 89});
    NxS[243] = new Table(41, 34, -1, new short[] {206, -1, -1, 206, -1, -1, 
          206, -1, -1, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206});
    NxS[244] = new Table(39, 36, -1, new short[] {238, 238, 237, -1, 243, 237, 
          -1, -1, 237, -1, -1, -1, -1, -1, -1, 237, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 237});
    NxS[245] = new Table(12, 39, -1, new short[] {246, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, 247, -1, -1, -1, -1, -1, -1, -1, -1, 244, -1, -1, 
          -1, -1, 247, -1, -1, -1, -1, -1, -1, -1, -1, -1, 233, -1, 244, -1, 
          246});
    NxS[246] = new Table(13, 42, -1, new short[] {257, 257, 257, -1, -1, -1, 
          257, -1, -1, 257, 257, -1, -1, -1, 257, -1, -1, 257, 257, -1, -1, -1, 
          -1, 257, -1, 257, 258, 258, 257, -1, -1, 257, -1, -1, 257, 257, -1, -1, 
          -1, -1, -1, 257});
    NxS[247] = new Table(39, 6, -1, new short[] {248, 248, 249, -1, -1, 249});
    NxS[248] = new Table(16, 29, -1, new short[] {250, -1, -1, -1, -1, -1, 
          -1, -1, -1, -1, -1, -1, -1, 251, -1, -1, -1, -1, -1, -1, -1, -1, 
          -1, -1, -1, 252, -1, -1, 252});
    NxS[249] = new Table(35, 38, 68, new short[] {29, 68, 68, 68, 72, 72, 
          122, 123, 68, 122, 124, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29});
    NxS[250] = new Table(19, 1, -1, new short[] {253});
    NxS[251] = new Table(35, 43, 68, new short[] {29, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29, 
          68, 68, 68, 68, 132});
    NxS[252] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 130, 123, 68, 130, 124, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[253] = new Table(16, 1, -1, new short[] {254});
    NxS[254] = new Table(43, 1, -1, new short[] {255});
    NxS[255] = new Table(44, 1, -1, new short[] {256});
    NxS[256] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 68, 68, 68, 68, 124, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[257] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 148, 148, 148, 68, 68, 68, 148, 68, 68, 148, 
          148, 68, 68, 68, 148, 68, 68, 148, 148, 68, 68, 68, 29, 148, 68, 148, 
          72, 72, 148, 143, 68, 148, 140, 68, 148, 148, 68, 68, 29, 29, 29, 148});
    NxS[258] = new Table(13, 42, -1, new short[] {259, 259, 259, 260, -1, -1, 
          259, -1, -1, 259, 259, -1, -1, -1, 259, -1, 261, 259, 259, -1, -1, -1, 
          -1, 259, -1, 259, -1, -1, 259, -1, -1, 259, -1, -1, 259, 259, -1, -1, 
          -1, -1, -1, 259});
    NxS[259] = new Table(1, 54, 68, new short[] {29, 30, 29, 29, 68, 29, 
          68, 68, 29, 68, 29, 68, 145, 145, 145, 68, 68, 68, 145, 68, 68, 145, 
          145, 68, 68, 68, 145, 68, 71, 145, 145, 68, 68, 68, 29, 145, 68, 145, 
          72, 72, 145, 146, 68, 145, 140, 68, 145, 145, 68, 68, 29, 29, 29, 145});
    NxS[260] = new Table(19, 1, -1, new short[] {262});
    NxS[261] = new Table(35, 43, 68, new short[] {29, 68, 68, 68, 68, 68, 
          68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 29, 29, 29, 68, 68, 68, 
          68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 29, 68, 68, 29, 68, 29, 
          68, 68, 68, 68, 136});
    NxS[262] = new Table(16, 1, -1, new short[] {263});
    NxS[263] = new Table(43, 1, -1, new short[] {264});
    NxS[264] = new Table(44, 1, -1, new short[] {265});
    NxS[265] = new Table(29, 44, 68, new short[] {71, 68, 68, 68, 68, 68, 
          29, 68, 68, 68, 72, 72, 68, 68, 68, 68, 140, 68, 68, 68, 68, 68, 
          29, 29, 29, 68, 68, 68, 68, 68, 68, 68, 68, 29, 30, 29, 29, 68, 
          29, 68, 68, 29, 68, 29});
    NxS[266] = new Table(27, 12, -1, new short[] {247, -1, 247, -1, -1, -1, 
          -1, -1, -1, -1, 247, 247});
    NxS[267] = new Table(27, 12, -1, new short[] {246, -1, 246, -1, -1, -1, 
          -1, -1, -1, -1, 246, 246});
    NxS[268] = new Table(2, 4, 202, new short[] {-1, 202, 202, 203});
    }

int NextState(int qStat) {
    if (chr == ScanBuff.EOF)
        return (qStat <= maxAccept && qStat != currentStart ? currentStart : eofNum);
    else {
        int rslt;
        int idx = Map(chr) - NxS[qStat].min;
        if (idx < 0) idx += 61;
        if ((uint)idx >= (uint)NxS[qStat].rng) rslt = NxS[qStat].dflt;
        else rslt = NxS[qStat].nxt[idx];
        return (rslt == goStart ? currentStart : rslt);
    }
}

int NextState() {
    if (chr == ScanBuff.EOF)
        return (state <= maxAccept && state != currentStart ? currentStart : eofNum);
    else {
        int rslt;
        int idx = Map(chr) - NxS[state].min;
        if (idx < 0) idx += 61;
        if ((uint)idx >= (uint)NxS[state].rng) rslt = NxS[state].dflt;
        else rslt = NxS[state].nxt[idx];
        return (rslt == goStart ? currentStart : rslt);
    }
}
#endregion


#if BACKUP
        // ====================== Nested class ==========================

        internal class Context // class used for automaton backup.
        {
            public int bPos;
            public int cNum;
            public int state;
            public int cChr;
        }
#endif // BACKUP

        // ==============================================================
        // ===== Nested classes for various ScanBuff derived classes ====
        // ==============================================================

        public sealed class StringBuff : ScanBuff
        {
            string str;        // input buffer
            int bPos;          // current position in buffer
            int sLen;

            public StringBuff(string str)
            {
                this.str = str;
                this.sLen = str.Length;
            }

            public override int Read()
            {
                if (bPos < sLen) return str[bPos++];
#if BABEL
                else if (bPos == sLen) { bPos++; return '\n'; }   // one strike, see newline
#endif // BABEL
                else { bPos++; return EOF; }                      // two strikes and you're out!
            }
            
            public override int ReadPos { get { return bPos - 1; } }

            public override int Peek()
            {
                if (bPos < sLen) return str[bPos];
                else return '\n';
            }

            public override string GetString(int beg, int end)
            {
                //  "end" can be greater than sLen with the BABEL
                //  option set.  Read returns a "virtual" EOL if
                //  an attempt is made to read past the end of the
                //  string buffer.  Without the guard any attempt 
                //  to fetch yytext for a token that includes the 
                //  EOL will throw an index exception.
                if (end > sLen) end = sLen;
                if (end <= beg) return ""; 
                else return str.Substring(beg, end - beg);
            }

            public override int Pos
            {
                get { return bPos; }
                set { bPos = value; }
            }
        }

       // ====================== Nested class ==========================
       //  The LineBuff class contributed by Nigel Horspool, 
       //  nigelh@cs.uvic.cs
       // ==============================================================

        public sealed class LineBuff : ScanBuff
        {
            IList<string> line;    // list of source lines from a file
            int numLines;          // number of strings in line list
            string curLine;        // current line in that list
            int cLine;             // index of current line in the list
            int curLen;            // length of current line
            int curLineStart;      // position of line start in whole file
            int curLineEnd;        // position of line end in whole file
            int maxPos;            // max position ever visited in whole file
            int cPos;              // ordinal number of chr in source

            // Constructed from a list of strings, one per source line.
            // The lines have had trailing '\n' characters removed.
            public LineBuff(IList<string> lineList)
            {
                line = lineList;
                numLines = line.Count;
                cPos = curLineStart = 0;
                curLine = numLines>0? line[0] : "";
                maxPos = curLineEnd = curLen = curLine.Length;
                cLine = 1;
            }

            public override int Read()
            {
                if (cPos < curLineEnd)
                    return curLine[cPos++ - curLineStart];
                if (cPos++ == curLineEnd)
                    return '\n';
                if (cLine >= numLines)
                    return EOF;
                curLine = line[cLine];
                curLen = curLine.Length;
                curLineStart = curLineEnd + 1;
                curLineEnd = curLineStart + curLen;
                if (curLineEnd>maxPos)
                    maxPos = curLineEnd;
                cLine++;
                return curLen>0? curLine[0] : '\n';
            }

            public override int Peek()
            {
                return (cPos < curLineEnd)? curLine[cPos - curLineStart] : '\n';
            }

            // To speed up searches for the line containing a position
            private int cachedPos = 0;
            private int cachedIx = 0;
            private int cachedLstart = 0;

            // Given a position pos within the entire source, the results are
            //   ix     -- the index of the containing line
            //   lstart -- the position of the first character on that line
            private void findIndex( int pos, out int ix, out int lstart )
            {
                if (pos >= cachedPos) {
                    ix = cachedIx;  lstart = cachedLstart;
                } else {
                    ix = lstart = 0;
                }
                for( ; ; ) {
                    int len = line[ix].Length + 1;
                    if (pos < lstart+len) break;
                    lstart += len;
                    ix++;
                }
                cachedPos = pos;
                cachedIx = ix;
                cachedLstart = lstart;
            }
        
            public override string GetString(int beg, int end)
            {
                if (beg >= maxPos || end <= beg) return "";
                int endIx, begIx, endLineStart, begLineStart;
                findIndex(beg, out begIx, out begLineStart);
                int begCol = beg - begLineStart;
                findIndex(end, out endIx, out endLineStart);
                int endCol = end - endLineStart;
                string s = line[begIx];
                if (begIx == endIx) {
                    // the usual case, substring all on one line
                    return (endCol <= s.Length)?
                        s.Substring(begCol, endCol-begCol)
                        : s.Substring(begCol) + "\n";
                }
                // the string spans multiple lines, yuk!
                StringBuilder sb = new StringBuilder();
                if (begCol < s.Length)
                    sb.Append(s.Substring(begCol));
                for( ; ; ) {
                    sb.Append("\n");
                    s = line[++begIx];
                    if (begIx >= endIx) break;
                    sb.Append(s);
                }
                if (endCol <= s.Length) {
                    sb.Append(s.Substring(0, endCol));
                } else {
                    sb.Append(s);
                    sb.Append("\n");
                }
                return sb.ToString();
            }

            public override int Pos
            {
                get { return cPos; }
                set {
                    cPos = value;
                    findIndex(cPos, out cLine, out curLineStart);
                    curLine = line[cLine];
                    curLineEnd = curLineStart+curLine.Length;
                }
            }
            
            public override int ReadPos { get { return cPos - 1; } }
        }
        
        // ====================== Nested class ==========================

        public sealed class StreamBuff : ScanBuff
        {
            BufferedStream bStrm;   // input buffer
            int delta = 1;          // number of bytes in chr, could be 0 for EOF.

            public StreamBuff(Stream str) { this.bStrm = new BufferedStream(str); }

            public override int Read() {
                int ch0 = bStrm.ReadByte();
                delta = (ch0 == EOF ? 0 : 1);
                return ch0; 
            }
            
            public override int ReadPos {
                get { return (int)bStrm.Position - delta; }
            }

            public override int Peek()
            {
                int rslt = bStrm.ReadByte();
                bStrm.Seek(-delta, SeekOrigin.Current);
                return rslt;
            }

            public override string GetString(int beg, int end)
            {
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                for (int i = 0; i < (end - beg); i++)
                    arr[i] = (char)bStrm.ReadByte();
                bStrm.Position = savePos;
                return new String(arr);
            }

            // Pos is the position *after* reading chr!
            public override int Pos
            {
                get { return (int)bStrm.Position; }
                set { bStrm.Position = value; }
            }
        }

        // ====================== Nested class ==========================

        /// <summary>
        /// This is the Buffer for UTF8 files.
        /// It attempts to read the encoding preamble, which for 
        /// this encoding should be unicode point \uFEFF which is 
        /// encoded as EF BB BF
        /// </summary>
        public class TextBuff : ScanBuff
        {
            protected BufferedStream bStrm;   // input buffer
            protected int delta = 1;          // length of chr, zero for EOF!
            
            private Exception BadUTF8()
            { return new Exception(String.Format("BadUTF8 Character")); }

            /// <summary>
            /// TextBuff factory.  Reads the file preamble
            /// and returns a TextBuff, LittleEndTextBuff or
            /// BigEndTextBuff according to the result.
            /// </summary>
            /// <param name="strm">The underlying stream</param>
            /// <returns></returns>
            public static TextBuff NewTextBuff(Stream strm)
            {
                // First check if this is a UTF16 file
                //
                int b0 = strm.ReadByte();
                int b1 = strm.ReadByte();

                if (b0 == 0xfe && b1 == 0xff)
                    return new BigEndTextBuff(strm);
                if (b0 == 0xff && b1 == 0xfe)
                    return new LittleEndTextBuff(strm);
                
                int b2 = strm.ReadByte();
                if (b0 == 0xef && b1 == 0xbb && b2 == 0xbf)
                    return new TextBuff(strm);
                //
                // There is no unicode preamble, so we
                // must go back to the UTF8 default.
                //
                strm.Seek(0, SeekOrigin.Begin);
                return new TextBuff(strm);
            }

            protected TextBuff(Stream str) { 
                this.bStrm = new BufferedStream(str);
            }

            public override int Read()
            {
                int ch0 = bStrm.ReadByte();
                int ch1;
                int ch2;
                if (ch0 < 0x7f)
                {
                    delta = (ch0 == EOF ? 0 : 1);
                    return ch0;
                }
                else if ((ch0 & 0xe0) == 0xc0)
                {
                    delta = 2;
                    ch1 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80)
                        return ((ch0 & 0x1f) << 6) + (ch1 & 0x3f);
                    else
                        throw BadUTF8();
                }
                else if ((ch0 & 0xf0) == 0xe0)
                {
                    delta = 3;
                    ch1 = bStrm.ReadByte();
                    ch2 = bStrm.ReadByte();
                    if ((ch1 & ch2 & 0xc0) == 0x80)
                        return ((ch0 & 0xf) << 12) + ((ch1 & 0x3f) << 6) + (ch2 & 0x3f);
                    else
                        throw BadUTF8();
                }
                else
                    throw BadUTF8();
            }

            public sealed override int ReadPos
            {
                get { return (int)bStrm.Position - delta; }
            }

            public sealed override int Peek()
            {
                int rslt = Read();
                bStrm.Seek(-delta, SeekOrigin.Current);
                return rslt;
            }

            /// <summary>
            /// Returns the string from the buffer between
            /// the given file positions.  This needs to be
            /// done carefully, as the number of characters
            /// is, in general, not equal to (end - beg).
            /// </summary>
            /// <param name="beg">Begin filepos</param>
            /// <param name="end">End filepos</param>
            /// <returns></returns>
            public sealed override string GetString(int beg, int end)
            {
                int i;
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                for (i = 0; bStrm.Position < end; i++)
                    arr[i] = (char)Read();
                bStrm.Position = savePos;
                return new String(arr, 0, i);
            }

            // Pos is the position *after* reading chr!
            public sealed override int Pos
            {
                get { return (int)bStrm.Position; }
                set { bStrm.Position = value; }
            }
        }

        // ====================== Nested class ==========================
        /// <summary>
        /// This is the Buffer for Big-endian UTF16 files.
        /// </summary>
        public sealed class BigEndTextBuff : TextBuff
        {
            internal BigEndTextBuff(Stream str) : base(str) { } // 

            public override int Read()
            {
                int ch0 = bStrm.ReadByte();
                int ch1 = bStrm.ReadByte();
                if (ch1 == EOF)
                {
                    // An EOF in either byte counts as an EOF
                    delta = (ch0 == EOF ? 0 : 1);
                    return -1;
                }
                else
                {
                    delta = 2;
                    return (ch0 << 8) + ch1;
                }
            }
        }
        
        // ====================== Nested class ==========================
        /// <summary>
        /// This is the Buffer for Little-endian UTF16 files.
        /// </summary>
        public sealed class LittleEndTextBuff : TextBuff
        {
            internal LittleEndTextBuff(Stream str) : base(str) { } // { this.bStrm = new BufferedStream(str); }

            public override int Read()
            {
                int ch0 = bStrm.ReadByte();
                int ch1 = bStrm.ReadByte();
                if (ch1 == EOF)
                {
                    // An EOF in either byte counts as an EOF
                    delta = (ch0 == EOF ? 0 : 1);
                    return -1;
                }
                else
                {
                    delta = 2;
                    return (ch1 << 8) + ch1;
                }
            }
        }
        // =================== End Nested classes =======================

        public Scanner(Stream file) {
            buffer = TextBuff.NewTextBuff(file); // selected by /unicode option
            this.cNum = -1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }

        public Scanner() { }

        void GetChr()
        {
            if (chr == '\n') 
            { 
                lineStartNum = cNum + 1; 
                lNum++; 
            }
            chr = buffer.Read();
            cNum++;
        }

        void MarkToken()
        {
            tokPos = buffer.ReadPos;
            tokNum = cNum;
            tokLin = lNum;
            tokCol = cNum - lineStartNum;
        }
        
        void MarkEnd()
        {
            tokTxt = null;
            tokLen = cNum - tokNum;
            tokEPos = buffer.ReadPos;
            tokELin = lNum;
            tokECol = cNum - lineStartNum;
        }

        // ==============================================================
        // =====    Initialization of string-based input buffers     ====
        // ==============================================================

        public void SetSource(string source, int offset)
        {
            this.buffer = new StringBuff(source);
            this.buffer.Pos = offset;
            this.cNum = offset - 1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }
        
        // ================ LineBuffer Initialization ===================

        public void SetSource(IList<string> source)
        {
            this.buffer = new LineBuff(source);
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            this.cNum = -1;
            GetChr();
        }
        
        // ==============================================================

#if BABEL
        //
        //  Get the next token for Visual Studio
        //
        //  "state" is the inout mode variable that maintains scanner
        //  state between calls, using the EolState property. In principle,
        //  if the calls of EolState are costly set could be called once
        //  only per line, at the start; and get called only at the end
        //  of the line. This needs more infrastructure ...
        //
        public int GetNext(ref int state, out int start, out int end)
        {
            Tokens next;
            int s, e;
            s = state;        // state at start
            EolState = state;
            next = (Tokens)Scan();
            state = EolState;
            e = state;       // state at end;
            start = tokPos;
            end = tokEPos - 1; // end is the index of last char.
            return (int)next;
        }        
#endif // BABEL

        // ======== IScanner<> Implementation =========

        public override int yylex()
        {
            // parserMax is set by reflecting on the Tokens
            // enumeration.  If maxParseTokeen is defined
            // that is used, otherwise int.MaxValue is used.
            int next;
            do { next = Scan(); } while (next >= parserMax);
            return next;
        }
        
        int yyleng { get { return tokLen; } }
        int yypos { get { return tokPos; } }
        int yyline { get { return tokLin; } }
        int yycol { get { return tokCol; } }

        public string yytext
        {
            get 
            {
                if (tokTxt == null) 
                    tokTxt = buffer.GetString(tokPos, tokEPos);
                return tokTxt;
            }
        }

        void yyless(int n) { 
            buffer.Pos = tokPos;
            // Must read at least one char, so set before start.
            cNum = tokNum - 1;
            for (int i = 0; i <= n; i++) GetChr();
            MarkEnd();
        }

        // ============ methods available in actions ==============

        internal int YY_START {
            get { return currentScOrd; }
            set { currentScOrd = value; } 
        }
        
        internal void BEGIN(int next) {
            currentScOrd = next;
            currentStart = startState[next];
        }

        // ============== The main tokenizer code =================

        int Scan()
        {
                for (; ; )
                {
                    int next;              // next state to enter                   
#if BACKUP
                    bool inAccept = false; // inAccept ==> current state is an accept state
                    Result rslt = Result.noMatch;
                    // skip "idle" transitions
#if LEFTANCHORS
                    if (lineStartNum == cNum && NextState(anchorState[currentScOrd]) != currentStart)
                        state = anchorState[currentScOrd];
                    else {
                        state = currentStart;
                        while (NextState() == state) {
                            GetChr();
                            if (lineStartNum == cNum) {
                                int anchor = anchorState[currentScOrd];
                                if (NextState(anchor) != state) {
                                    state = anchor; 
                                    break;
                                }
                            }
                        }
                    }
#else // !LEFTANCHORS
                    state = currentStart;
                    while (NextState() == state) 
                        GetChr(); // skip "idle" transitions
#endif // LEFTANCHORS
                    MarkToken();
                    
                    while ((next = NextState()) != currentStart)
                        if (inAccept && next > maxAccept) // need to prepare backup data
                        {
                            Context ctx = new Context();
                            rslt = Recurse2(ctx, next);
                            if (rslt == Result.noMatch) RestoreStateAndPos(ctx);
                            break;
                        }
                        else
                        {
                            state = next;
                            GetChr();
                            if (state <= maxAccept) inAccept = true;
                        }
#else // !BACKUP
#if LEFTANCHORS
                    if (lineStartNum == cNum) {
                        int anchor = anchorState[currentScOrd];
                        if (NextState(anchor) != currentStart)
                            state = anchor;
                    }
                    else {
                        state = currentStart;
                        while (NextState() == state) {
                            GetChr();
                            if (lineStartNum == cNum) {
                                int anchor = anchorState[currentScOrd];
                                if (NextState(anchor) != state) {
                                    state = anchor;
                                    break;
                                }
                            }
                        }
                    }
#else // !LEFTANCHORS
                    state = currentStart;
                    while (NextState() == state) 
                        GetChr(); // skip "idle" transitions
#endif // LEFTANCHORS
                    MarkToken();
                    // common code
                    while ((next = NextState()) != currentStart)
                    {
                        state = next;
                        GetChr();
                    }
#endif // BACKUP
                    if (state > maxAccept) 
                        state = currentStart;
                    else
                    {
                        MarkEnd();
#region ActionSwitch
#pragma warning disable 162
    switch (state)
    {
        case eofNum:
            switch (currentStart) {
                case 205:
{ }
                    break;
            }
            return (int)Tokens.EOF;
        case 1:
        case 5:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
Errors.Add(SourceUnit, string.Format("bad input:{0}", yytext), 
                          new SourceSpan( new SourceLocation(1,tokLin,tokCol + 1) , new SourceLocation(1,tokLin,tokCol + yytext.Length + 1)), 2, Microsoft.Scripting.Hosting.Severity.Error);
            break;
        case 2:
;
            break;
        case 3:
        case 4:
;
            break;
        case 6:
{  }
            break;
        case 8:
return Make(Tokens.RBRACE);
            break;
        case 14:
return Make(Tokens.LBRACK);
            break;
        case 15:
return Make(Tokens.RBRACK);
            break;
        case 16:
return Make(Tokens.LBRACE);
            break;
        case 17:
return Make(Tokens.QUASIQUOTE);
            break;
        case 18:
return Make(Tokens.QUOTE);
            break;
        case 19:
return Make(Tokens.UNQUOTE);
            break;
        case 20:
return Make(Tokens.UNQUOTESPLICING);
            break;
        case 21:
        case 24:
        case 25:
        case 26:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
Errors.Add(SourceUnit, string.Format("bad dot:{0}", yytext), 
                          new SourceSpan( new SourceLocation(1,tokLin,tokCol + 1) , new SourceLocation(1,tokLin,tokCol + yytext.Length + 1)), 2, Microsoft.Scripting.Hosting.Severity.Error);
            break;
        case 22:
        case 23:
yyless(1); return Make(Tokens.DOT);
            break;
        case 27:
        case 28:
        case 95:
return MakeSymbol();
            break;
        case 29:
        case 30:
return MakeNumber();
            break;
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 94:
Errors.Add(SourceUnit, string.Format("bad identifier:{0}", yytext), 
                          new SourceSpan( new SourceLocation(1,tokLin,tokCol + 1) , new SourceLocation(1,tokLin,tokCol + yytext.Length + 1)), 2, Microsoft.Scripting.Hosting.Severity.Error);
            break;
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 93:
        case 97:
        case 98:
        case 99:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case 128:
        case 129:
        case 130:
        case 131:
        case 132:
        case 133:
        case 134:
        case 135:
        case 136:
        case 137:
        case 138:
        case 139:
        case 140:
        case 141:
        case 142:
        case 143:
        case 144:
        case 145:
        case 146:
        case 147:
        case 148:
        case 149:
Errors.Add(SourceUnit, string.Format("bad number:{0}", yytext), 
                          new SourceSpan( new SourceLocation(1,tokLin,tokCol + 1) , new SourceLocation(1,tokLin,tokCol + yytext.Length + 1)), 2, Microsoft.Scripting.Hosting.Severity.Error);
            break;
        case 96:
return Make(Tokens.STRING);
            break;
        case 100:
yy_push_state(ML_COMMENT);
            break;
        case 101:
return Make(Tokens.IGNOREDATUM);
            break;
        case 102:
return Make(Tokens.VECTORLBRACE);
            break;
        case 103:
return Make(Tokens.QUASISYNTAX);
            break;
        case 104:
return Make(Tokens.SYNTAX);
            break;
        case 105:
return Make(Tokens.UNSYNTAX);
            break;
        case 106:
return Make(Tokens.UNSYNTAXSPLICING);
            break;
        case 121:
return Make(Tokens.BYTEVECTORLBRACE);
            break;
        case 150:
        case 154:
        case 155:
        case 156:
        case 157:
        case 158:
        case 159:
        case 160:
        case 161:
        case 162:
        case 163:
        case 164:
        case 165:
        case 166:
        case 167:
        case 168:
        case 169:
        case 170:
        case 171:
        case 172:
        case 173:
        case 174:
        case 175:
        case 176:
        case 177:
        case 178:
        case 179:
        case 180:
        case 181:
        case 182:
        case 183:
        case 184:
        case 185:
        case 186:
        case 187:
        case 188:
        case 189:
        case 190:
        case 191:
        case 192:
        case 193:
        case 194:
        case 195:
        case 196:
        case 197:
        case 198:
Errors.Add(SourceUnit, string.Format("bad char:{0}", yytext), 
                          new SourceSpan( new SourceLocation(1,tokLin,tokCol + 1) , new SourceLocation(1,tokLin,tokCol + yytext.Length + 1)), 2, Microsoft.Scripting.Hosting.Severity.Error);
            break;
        case 151:
        case 152:
        case 153:
return MakeChar();
            break;
        case 199:
Errors.Add(SourceUnit, string.Format("bad boolean:{0}", yytext), 
                          new SourceSpan( new SourceLocation(1,tokLin,tokCol + 1) , new SourceLocation(1,tokLin,tokCol + yytext.Length + 1)), 2, Microsoft.Scripting.Hosting.Severity.Error);
            break;
        case 200:
        case 201:
return MakeBoolean();
            break;
        case 202:
;
            break;
        case 203:
;
            break;
        case 204:
yy_pop_state();
            break;
        default:
            break;
    }
#pragma warning restore 162
#endregion
                    }
                }
        }

#if BACKUP
        Result Recurse2(Context ctx, int next)
        {
            // Assert: at entry "state" is an accept state AND
            //         NextState(state, chr) != currentStart AND
            //         NextState(state, chr) is not an accept state.
            //
            bool inAccept;
            SaveStateAndPos(ctx);
            state = next;
            if (state == eofNum) return Result.accept;
            GetChr();
            inAccept = false;

            while ((next = NextState()) != currentStart)
            {
                if (inAccept && next > maxAccept) // need to prepare backup data
                    SaveStateAndPos(ctx);
                state = next;
                if (state == eofNum) return Result.accept;
                GetChr(); 
                inAccept = (state <= maxAccept);
            }
            if (inAccept) return Result.accept; else return Result.noMatch;
        }

        void SaveStateAndPos(Context ctx)
        {
            ctx.bPos  = buffer.Pos;
            ctx.cNum  = cNum;
            ctx.state = state;
            ctx.cChr  = chr;
        }

        void RestoreStateAndPos(Context ctx)
        {
            buffer.Pos = ctx.bPos;
            cNum  = ctx.cNum;
            state = ctx.state;
            chr   = ctx.cChr;
        }

        void RestorePos(Context ctx) { buffer.Pos = ctx.bPos; cNum = ctx.cNum; }
#endif // BACKUP

        // ============= End of the tokenizer code ================

#if STACK        
        internal void yy_clear_stack() { scStack.Clear(); }
        internal int yy_top_state() { return scStack.Peek(); }
        
        internal void yy_push_state(int state)
        {
            scStack.Push(currentScOrd);
            BEGIN(state);
        }
        
        internal void yy_pop_state()
        {
            // Protect against input errors that pop too far ...
            if (scStack.Count > 0) {
				int newSc = scStack.Pop();
				BEGIN(newSc);
            } // Otherwise leave stack unchanged.
        }
 #endif // STACK

        internal void ECHO() { Console.Out.Write(yytext); }
        
    } // end class Scanner
} // end namespace
