;;; Copyright (c) 2006, 2007 Abdulaziz Ghuloum and Kent Dybvig
;;; 
;;; Permission is hereby granted, free of charge, to any person obtaining a
;;; copy of this software and associated documentation files (the "Software"),
;;; to deal in the Software without restriction, including without limitation
;;; the rights to use, copy, modify, merge, publish, distribute, sublicense,
;;; and/or sell copies of the Software, and to permit persons to whom the
;;; Software is furnished to do so, subject to the following conditions:
;;; 
;;; The above copyright notice and this permission notice shall be included in
;;; all copies or substantial portions of the Software.
;;; 
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
;;; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;;; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE. 

(import 
  (rnrs base)
  (rnrs control)
  (rnrs io simple)
  (rnrs io ports)
  (rnrs lists)
  (rnrs files)
  (psyntax internal)
  (psyntax compat)
  (psyntax library-manager)
  (psyntax expander)
  (only (ironscheme) time-it)
  )


(define scheme-library-files
  '(
    "ironscheme/base.ss"
    "ironscheme/clr.ss"
    "ironscheme/hashtables.ss"
    "ironscheme/files.ss"
    "ironscheme/lists.ss"
    "ironscheme/bytevectors.ss"
    "ironscheme/control.ss"
    "ironscheme/enums.ss"
    "ironscheme/eval.ss"
    "ironscheme/exceptions.ss"
    "ironscheme/conditions.ss"
    "ironscheme/mutable-pairs.ss"
    "ironscheme/mutable-strings.ss"
    "ironscheme/programs.ss"
    "ironscheme/r5rs.ss"
    "ironscheme/sorting.ss"
    "ironscheme/syntax-case.ss"
    "ironscheme/unicode.ss"
    "ironscheme/arithmetic/bitwise.ss"
    "ironscheme/arithmetic/fixnums.ss"
    "ironscheme/arithmetic/flonums.ss"
    "ironscheme/io/conditions.ss"
    "ironscheme/io/ports.ss"
    "ironscheme/io/simple.ss"
    "ironscheme/records/inspection.ss"
    "ironscheme/records/procedural.ss"
    "ironscheme/records/syntactic.ss"
    "ironscheme/build.ss"
    "psyntax/compat.ss"
    "psyntax/internal.ss"
    "psyntax/config.ss"
    "psyntax/library-manager.ss"
    "psyntax/builders.ss"
    "psyntax/expander.ss"
    "psyntax/main.ss"
    ))


(define psyntax-system-macros
  '((define              (define))
    (define-syntax       (define-syntax))
    (module              (module))
    (begin               (begin))
    (library             (library))
    (import              (import))
    (set!                (set!))
    (let-syntax          (let-syntax))
    (letrec-syntax       (letrec-syntax))
    (foreign-call        (core-macro . foreign-call))
    (quote               (core-macro . quote))
    (syntax-case         (core-macro . syntax-case))
    (syntax              (core-macro . syntax))
    (lambda              (core-macro . lambda))
    (case-lambda         (core-macro . case-lambda))
    (type-descriptor     (core-macro . type-descriptor))
    (letrec              (core-macro . letrec))
    (letrec*             (core-macro . letrec*))
    (if                  (core-macro . if))
    (when                (core-macro . when))         
    (unless              (core-macro . unless))
    (parameterize        (core-macro . parameterize))
    (case                (core-macro . case))
    (record-type-descriptor (core-macro . record-type-descriptor))
    (record-constructor-descriptor (core-macro . record-constructor-descriptor))
    (let*-values         (macro . let*-values))
    (let-values          (macro . let-values))
    (define-struct       (macro . define-struct))
    (include             (macro . include))
    (include-into        (macro . include-into))
    (syntax-rules        (macro . syntax-rules))
    (quasiquote          (macro . quasiquote))
    (quasisyntax         (macro . quasisyntax))
    (with-syntax         (macro . with-syntax))
    (identifier-syntax   (macro . identifier-syntax))
    (let                 (macro . let))
    (let*                (macro . let*))
    (cond                (macro . cond))
    (do                  (macro . do))
    (and                 (macro . and))
    (or                  (macro . or))
    (time                (macro . time))
    (delay               (macro . delay))
    (endianness          (macro . endianness))
    (assert              (macro . assert))
    (...                 (macro . ...))
    (=>                  (macro . =>))
    (else                (macro . else))
    (_                   (macro . _))
    (unquote             (macro . unquote))
    (unquote-splicing    (macro . unquote-splicing))
    (unsyntax            (macro . unsyntax))
    (unsyntax-splicing   (macro . unsyntax-splicing))
    (trace-lambda        (macro . trace-lambda))
    (trace-define        (macro . trace-define))
    (trace-define-syntax (macro . trace-define-syntax))
    ;;; new
    (guard                 (macro . guard))
    (eol-style             (macro . eol-style))
    (buffer-mode           (macro . buffer-mode))
    (file-options          (macro . file-options))
    (error-handling-mode   (macro . error-handling-mode))
    (fields                (macro . fields)) 
    (mutable               (macro . mutable))
    (immutable             (macro . immutable)) 
    (parent                (macro . parent))
    (protocol              (macro . protocol))
    (sealed                (macro . sealed))
    (opaque                (macro . opaque ))
    (nongenerative         (macro . nongenerative))
    (parent-rtd            (macro . parent-rtd))
    (define-record-type    (macro . define-record-type))
    (define-enumeration    (macro . define-enumeration))
    (define-condition-type (macro . define-condition-type))
    ;;; for (record-type-descriptor &condition-type) and
    ;;; (record-constructor-descriptor &condition-type) to
    ;;; expand properly, the implementation must export 
    ;;; the identifiers &condition-type-rtd, which must 
    ;;; be bound to the run-time value of the rtd, and 
    ;;; &condition-type-rcd which must be bound to the 
    ;;; corresponding record-constructor-descriptor.
    (&condition                ($core-rtd . (&condition-rtd &condition-rcd)))
    (&message                  ($core-rtd . (&message-rtd &message-rcd)))
    (&warning                  ($core-rtd . (&warning-rtd &warning-rcd )))
    (&serious                  ($core-rtd . (&serious-rtd &serious-rcd)))
    (&error                    ($core-rtd . (&error-rtd &error-rcd)))
    (&violation                ($core-rtd . (&violation-rtd &violation-rcd)))
    (&assertion                ($core-rtd . (&assertion-rtd &assertion-rcd)))
    (&irritants                ($core-rtd . (&irritants-rtd &irritants-rcd)))
    (&who                      ($core-rtd . (&who-rtd &who-rcd)))
    (&non                      ($core-rtd . (&non-continuable-rtd &non-continuable-rcd)))
    (&implementation-restriction  ($core-rtd . (&implementation-restriction-rtd &implementation-restriction-rcd)))
    (&lexical                  ($core-rtd . (&lexical-rtd &lexical-rcd)))
    (&syntax                   ($core-rtd . (&syntax-rtd &syntax-rcd)))
    (&undefined                ($core-rtd . (&undefined-rtd &undefined-rcd)))
    (&non-continuable          ($core-rtd . (&non-continuable-rtd &non-continuable-rcd)))
    (&i/o                      ($core-rtd . (&i/o-rtd &i/o-rcd)))
    (&i/o-read                 ($core-rtd . (&i/o-read-rtd &i/o-read-rcd)))
    (&i/o-write                ($core-rtd . (&i/o-write-rtd &i/o-write-rcd)))
    (&i/o-invalid-position     ($core-rtd . (&i/o-invalid-position-rtd &i/o-invalid-position-rcd)))
    (&i/o-filename             ($core-rtd . (&i/o-filename-rtd &i/o-filename-rcd)))
    (&i/o-file-protection      ($core-rtd . (&i/o-file-protection-rtd &i/o-file-protection-rcd)))
    (&i/o-file-is-read-only    ($core-rtd . (&i/o-file-is-read-only-rtd &i/o-fie-is-read-only-rcd)))
    (&i/o-file-already-exists  ($core-rtd . (&i/o-file-already-exists-rtd &i/o-file-already-exists-rcd)))
    (&i/o-file-does-not-exist  ($core-rtd . (&i/o-file-does-not-exist-rtd &i/o-file-does-not-exist-rcd)))
    (&i/o-port                 ($core-rtd . (&i/o-port-rtd &i/o-port-rcd)))
    (&i/o-decoding             ($core-rtd . (&i/o-decoding-rtd &i/o-decoding-rcd)))
    (&i/o-encoding             ($core-rtd . (&i/o-encoding-rtd &i/o-encoding-rcd)))
    (&no-infinities            ($core-rtd . (&no-infinities-rtd &no-infinities-rcd)))
    (&no-nans                  ($core-rtd . (&no-nans-rtd &no-nans-rcd)))
    ))

(define (macro-identifier x)
  (assq x psyntax-system-macros))

(define library-legend
  ;; abbr.       name                             visible? required?
  '((interaction (ikarus interaction)                  #t    #f)
    (i           (ironscheme)                          #t    #f)
    (ir          (ironscheme reader)                   #t    #t)
    (ii          (ironscheme interaction)              #t    #t)
    (is-clr-int  (ironscheme clr internal)             #t    #t)
    (ne          (psyntax null-environment-5)          #t    #f)
    (se          (psyntax scheme-report-environment-5) #t    #f)
    (cm          (psyntax modules)                     #t    #f)
    (parameters  (chez parameters)                     #t    #f)
    (r           (rnrs)                                #t    #t)
    (r5          (rnrs r5rs)                           #t    #t)
    (ct          (rnrs control)                        #t    #t)
    (ev          (rnrs eval)                           #t    #t)
    (mp          (rnrs mutable-pairs)                  #t    #t)
    (ms          (rnrs mutable-strings)                #t    #t)
    (pr          (rnrs programs)                       #t    #t)
    (sc          (rnrs syntax-case)                    #t    #t)
    (fi          (rnrs files)                          #t    #t)
    (sr          (rnrs sorting)                        #t    #t)
    (ba          (rnrs base)                           #t    #t)
    (ls          (rnrs lists)                          #t    #t)
    (is          (rnrs io simple)                      #t    #t)
    (bv          (rnrs bytevectors)                    #t    #t)
    (uc          (rnrs unicode)                        #t    #t)
    (ex          (rnrs exceptions)                     #t    #t)
    (bw          (rnrs arithmetic bitwise)             #t    #t)
    (fx          (rnrs arithmetic fixnums)             #t    #t)
    (fl          (rnrs arithmetic flonums)             #t    #t)
    (ht          (rnrs hashtables)                     #t    #t)
    (ip          (rnrs io ports)                       #t    #t)
    (en          (rnrs enums)                          #t    #t)
    (co          (rnrs conditions)                     #t    #t)
    (ri          (rnrs records inspection)             #t    #t)
    (rp          (rnrs records procedural)             #t    #t)
    (rs          (rnrs records syntactic)              #t    #t)
    ($all        (psyntax system $all)                 #f    #t)
    ($boot       (psyntax system $bootstrap)           #f    #t)
    ))

;;; required? flag means that said library is required for 
;;; building the system.  The only non-r6rs required libraries
;;; should be (psyntax system $bootstrap) and (psyntax system $all).
;;; (psyntax system $bootstrap) should export, at a minimum, the 
;;; following procedures: gensym, symbol-value, set-symbol-value!,
;;; eval-core, and pretty-print.
;;; (psyntax system $all) is fabricated by the system to include 
;;; every identifier in the system.


(define identifier->library-map
  '(
    ;;;
    (import                                     i r) ;non standard
    (library                                    i r) ;non standard
    (include                                    i)
    (include-into                               i)
    (expand                                     i)
    (installed-libraries                        i)
    (library-extensions                         i)
    (library-path                               i)
    (library-locator                            i)
    (make-parameter                             i)
    (parameterize                               i)
    (clr-library-locator                        i)
    (time                                       i)
    (time-it                                    i)
    (lambda                                     i r ba se ne)
    (and                                        i r ba se ne)
    (begin                                      i r ba se ne)
    (case                                       i r ba se ne)
    (cond                                       i r ba se ne)
    (define                                     i r ba se ne)
    (define-syntax                              i r ba se ne)
    (identifier-syntax                          i r ba)
    (if                                         i r ba se ne)
    (let                                        i r ba se ne)
    (let*                                       i r ba se ne)
    (let*-values                                i r ba)
    (let-syntax                                 i r ba se ne)
    (let-values                                 i r ba)
    (letrec                                     i r ba se ne)
    (letrec*                                    i r ba)
    (letrec-syntax                              i r ba se ne)
    (or                                         i r ba se ne)
    (quasiquote                                 i r ba se ne)
    (quote                                      i r ba se ne)
    (set!                                       i r ba se ne)
    (syntax-rules                               i r ba se ne)
    (unquote                                    i r ba se ne)
    (unquote-splicing                           i r ba se ne)
    (<                                          i r ba se)
    (<=                                         i r ba se)
    (=                                          i r ba se)
    (>                                          i r ba se)
    (>=                                         i r ba se)
    (+                                          i r ba se)
    (-                                          i r ba se)
    (*                                          i r ba se)
    (/                                          i r ba se)
    (abs                                        i r ba se)
    (acos                                       i r ba se)
    (angle                                      i r ba se)
    (append                                     i r ba se)
    (apply                                      i r ba se)
    (asin                                       i r ba se)
    (assert                                     i r ba)
    (assertion-violation                        i r ba)
    (atan                                       i r ba se)
    (boolean=?                                  i r ba)
    (boolean?                                   i r ba se)
    (car                                        i r ba se)
    (cdr                                        i r ba se)
    (caar                                       i r ba se)
    (cadr                                       i r ba se)
    (cdar                                       i r ba se)
    (cddr                                       i r ba se)
    (caaar                                      i r ba se)
    (caadr                                      i r ba se)
    (cadar                                      i r ba se)
    (caddr                                      i r ba se)
    (cdaar                                      i r ba se)
    (cdadr                                      i r ba se)
    (cddar                                      i r ba se)
    (cdddr                                      i r ba se)
    (caaaar                                     i r ba se)
    (caaadr                                     i r ba se)
    (caadar                                     i r ba se)
    (caaddr                                     i r ba se)
    (cadaar                                     i r ba se)
    (cadadr                                     i r ba se)
    (caddar                                     i r ba se)
    (cadddr                                     i r ba se)
    (cdaaar                                     i r ba se)
    (cdaadr                                     i r ba se)
    (cdadar                                     i r ba se)
    (cdaddr                                     i r ba se)
    (cddaar                                     i r ba se)
    (cddadr                                     i r ba se)
    (cdddar                                     i r ba se)
    (cddddr                                     i r ba se)
    (call-with-current-continuation             i r ba se)
    (call/cc                                    i r ba)
    (call-with-values                           i r ba se)
    (ceiling                                    i r ba se)
    (char->integer                              i r ba se)
    (char<=?                                    i r ba se)
    (char<?                                     i r ba se)
    (char=?                                     i r ba se)
    (char>=?                                    i r ba se)
    (char>?                                     i r ba se)
    (char?                                      i r ba se)
    (complex?                                   i r ba se)
    (cons                                       i r ba se)
    (cos                                        i r ba se)
    (denominator                                i r ba se)
    (div                                        i r ba)
    (mod                                        i r ba)
    (div-and-mod                                i r ba)
    (div0                                       i r ba)
    (mod0                                       i r ba)
    (div0-and-mod0                              i r ba)
    (dynamic-wind                               i r ba se)
    (eq?                                        i r ba se)
    (equal?                                     i r ba se)
    (eqv?                                       i r ba se)
    (error                                      i r ba)
    (even?                                      i r ba se)
    (exact                                      i r ba)
    (exact-integer-sqrt                         i r ba)
    (exact?                                     i r ba se)
    (exp                                        i r ba se)
    (expt                                       i r ba se)
    (finite?                                    i r ba)
    (floor                                      i r ba se)
    (for-each                                   i r ba se)
    (gcd                                        i r ba se)
    (imag-part                                  i r ba se)
    (inexact                                    i r ba)
    (inexact?                                   i r ba se)
    (infinite?                                  i r ba)
    (integer->char                              i r ba se)
    (integer-valued?                            i r ba)
    (integer?                                   i r ba se)
    (lcm                                        i r ba se)
    (length                                     i r ba se)
    (list                                       i r ba se)
    (list->string                               i r ba se)
    (list->vector                               i r ba se)
    (list-ref                                   i r ba se)
    (list-tail                                  i r ba se)
    (list?                                      i r ba se)
    (log                                        i r ba se)
    (magnitude                                  i r ba se)
    (make-polar                                 i r ba se)
    (make-rectangular                           i r ba se)
    (make-string                                i r ba se)
    (make-vector                                i r ba se)
    (map                                        i r ba se)
    (max                                        i r ba se)
    (min                                        i r ba se)
    (nan?                                       i r ba)
    (negative?                                  i r ba se)
    (not                                        i r ba se)
    (null?                                      i r ba se)
    (number->string                             i r ba se)
    (number?                                    i r ba se)
    (numerator                                  i r ba se)
    (odd?                                       i r ba se)
    (pair?                                      i r ba se)
    (positive?                                  i r ba se)
    (procedure?                                 i r ba se)
    (rational-valued?                           i r ba)
    (rational?                                  i r ba se)
    (rationalize                                i r ba se)
    (real-part                                  i r ba se)
    (real-valued?                               i r ba)
    (real?                                      i r ba se)
    (reverse                                    i r ba se)
    (round                                      i r ba se)
    (sin                                        i r ba se)
    (sqrt                                       i r ba se)
    (string                                     i r ba se)
    (string->list                               i r ba se)
    (string->number                             i r ba se)
    (string->symbol                             i r ba se)
    (string-append                              i r ba se)
    (string-copy                                i r ba se)
    (string-for-each                            i r ba)
    (string-length                              i r ba se)
    (string-ref                                 i r ba se)
    (string<=?                                  i r ba se)
    (string<?                                   i r ba se)
    (string=?                                   i r ba se)
    (string>=?                                  i r ba se)
    (string>?                                   i r ba se)
    (string?                                    i r ba se)
    (substring                                  i r ba se)
    (symbol->string                             i r ba se)
    (symbol=?                                   i r ba)
    (symbol?                                    i r ba se)
    (tan                                        i r ba se)
    (truncate                                   i r ba se)
    (values                                     i r ba se)
    (vector                                     i r ba se)
    (vector->list                               i r ba se)
    (vector-fill!                               i r ba se)
    (vector-for-each                            i r ba)
    (vector-length                              i r ba se)
    (vector-map                                 i r ba)
    (vector-ref                                 i r ba se)
    (vector-set!                                i r ba se)
    (vector?                                    i r ba se)
    (zero?                                      i r ba se)
    (...                                        i r ba sc se)
    (=>                                         i r ba ex se)
    (_                                          i r ba sc)
    (else                                       i r ba ex se)
    ;;;
    (bitwise-arithmetic-shift                   i r bw)
    (bitwise-arithmetic-shift-left              i r bw)
    (bitwise-arithmetic-shift-right             i r bw)
    (bitwise-not                                i r bw)
    (bitwise-and                                i r bw)
    (bitwise-ior                                i r bw)
    (bitwise-xor                                i r bw)
    (bitwise-bit-count                          i r bw)
    (bitwise-bit-field                          i r bw)
    (bitwise-bit-set?                           i r bw)
    (bitwise-copy-bit                           i r bw)
    (bitwise-copy-bit-field                     i r bw)
    (bitwise-first-bit-set                      i r bw)
    (bitwise-if                                 i r bw)
    (bitwise-length                             i r bw)
    (bitwise-reverse-bit-field                  i r bw)
    (bitwise-rotate-bit-field                   i r bw)
    ;;;
    (fixnum?                                    i r fx)
    (fixnum-width                               i r fx) 
    (least-fixnum                               i r fx) 
    (greatest-fixnum                            i r fx) 
    (fx*                                        i r fx)
    (fx*/carry                                  i r fx)
    (fx+                                        i r fx)
    (fx+/carry                                  i r fx)
    (fx-                                        i r fx)
    (fx-/carry                                  i r fx)
    (fx<=?                                      i r fx)
    (fx<?                                       i r fx)
    (fx=?                                       i r fx)
    (fx>=?                                      i r fx)
    (fx>?                                       i r fx)
    (fxand                                      i r fx)
    (fxarithmetic-shift                         i r fx)
    (fxarithmetic-shift-left                    i r fx)
    (fxarithmetic-shift-right                   i r fx)
    (fxbit-count                                i r fx)
    (fxbit-field                                i r fx)
    (fxbit-set?                                 i r fx)
    (fxcopy-bit                                 i r fx)
    (fxcopy-bit-field                           i r fx)
    (fxdiv                                      i r fx)
    (fxdiv-and-mod                              i r fx)
    (fxdiv0                                     i r fx)
    (fxdiv0-and-mod0                            i r fx)
    (fxeven?                                    i r fx)
    (fxfirst-bit-set                            i r fx)
    (fxif                                       i r fx)
    (fxior                                      i r fx)
    (fxlength                                   i r fx)
    (fxmax                                      i r fx)
    (fxmin                                      i r fx)
    (fxmod                                      i r fx)
    (fxmod0                                     i r fx)
    (fxnegative?                                i r fx)
    (fxnot                                      i r fx)
    (fxodd?                                     i r fx)
    (fxpositive?                                i r fx)
    (fxreverse-bit-field                        i r fx)
    (fxrotate-bit-field                         i r fx)
    (fxxor                                      i r fx)
    (fxzero?                                    i r fx)
    ;;;
    (fixnum->flonum                             i r fl)
    (fl*                                        i r fl)
    (fl+                                        i r fl)
    (fl-                                        i r fl)
    (fl/                                        i r fl)
    (fl<=?                                      i r fl)
    (fl<?                                       i r fl)
    (fl=?                                       i r fl)
    (fl>=?                                      i r fl)
    (fl>?                                       i r fl)
    (flabs                                      i r fl)
    (flacos                                     i r fl)
    (flasin                                     i r fl)
    (flatan                                     i r fl)
    (flceiling                                  i r fl)
    (flcos                                      i r fl)
    (fldenominator                              i r fl)
    (fldiv                                      i r fl)
    (fldiv-and-mod                              i r fl)
    (fldiv0                                     i r fl)
    (fldiv0-and-mod0                            i r fl)
    (fleven?                                    i r fl)
    (flexp                                      i r fl)
    (flexpt                                     i r fl)
    (flfinite?                                  i r fl)
    (flfloor                                    i r fl)
    (flinfinite?                                i r fl)
    (flinteger?                                 i r fl)
    (fllog                                      i r fl)
    (flmax                                      i r fl)
    (flmin                                      i r fl)
    (flmod                                      i r fl)
    (flmod0                                     i r fl)
    (flnan?                                     i r fl)
    (flnegative?                                i r fl)
    (flnumerator                                i r fl)
    (flodd?                                     i r fl)
    (flonum?                                    i r fl)
    (flpositive?                                i r fl)
    (flround                                    i r fl)
    (flsin                                      i r fl)
    (flsqrt                                     i r fl)
    (fltan                                      i r fl)
    (fltruncate                                 i r fl)
    (flzero?                                    i r fl)
    (real->flonum                               i r fl)
    (make-no-infinities-violation               i r fl)
    (make-no-nans-violation                     i r fl)
    (&no-infinities                             i r fl)
    (no-infinities-violation?                   i r fl)
    (&no-nans                                   i r fl)
    (no-nans-violation?                         i r fl)
    ;;;
    (bytevector->sint-list                      i r bv)
    (bytevector->u8-list                        i r bv)
    (bytevector->uint-list                      i r bv)
    (bytevector-copy                            i r bv)
    (bytevector-copy!                           i r bv)
    (bytevector-fill!                           i r bv)
    (bytevector-ieee-double-native-ref          i r bv)
    (bytevector-ieee-double-native-set!         i r bv)
    (bytevector-ieee-double-ref                 i r bv)
    (bytevector-ieee-double-set!                i r bv)
    (bytevector-ieee-single-native-ref          i r bv)
    (bytevector-ieee-single-native-set!         i r bv)
    (bytevector-ieee-single-ref                 i r bv)
    (bytevector-ieee-single-set!                i r bv)    
    (bytevector-length                          i r bv)
    (bytevector-s16-native-ref                  i r bv)
    (bytevector-s16-native-set!                 i r bv)
    (bytevector-s16-ref                         i r bv)
    (bytevector-s16-set!                        i r bv)
    (bytevector-s32-native-ref                  i r bv)
    (bytevector-s32-native-set!                 i r bv)
    (bytevector-s32-ref                         i r bv)
    (bytevector-s32-set!                        i r bv)
    (bytevector-s64-native-ref                  i r bv)
    (bytevector-s64-native-set!                 i r bv)
    (bytevector-s64-ref                         i r bv)
    (bytevector-s64-set!                        i r bv)
    (bytevector-s8-ref                          i r bv)
    (bytevector-s8-set!                         i r bv)
    (bytevector-sint-ref                        i r bv)
    (bytevector-sint-set!                       i r bv)
    (bytevector-u16-native-ref                  i r bv)
    (bytevector-u16-native-set!                 i r bv)
    (bytevector-u16-ref                         i r bv)
    (bytevector-u16-set!                        i r bv)
    (bytevector-u32-native-ref                  i r bv)
    (bytevector-u32-native-set!                 i r bv)
    (bytevector-u32-ref                         i r bv)
    (bytevector-u32-set!                        i r bv)
    (bytevector-u64-native-ref                  i r bv)
    (bytevector-u64-native-set!                 i r bv)
    (bytevector-u64-ref                         i r bv)
    (bytevector-u64-set!                        i r bv)
    (bytevector-u8-ref                          i r bv)
    (bytevector-u8-set!                         i r bv)
    (bytevector-uint-ref                        i r bv)
    (bytevector-uint-set!                       i r bv)
    (bytevector=?                               i r bv)
    (bytevector?                                i r bv)
    (endianness                                 i r bv)
    (native-endianness                          i r bv)
    (sint-list->bytevector                      i r bv)
    (string->utf16                              i r bv)
    (string->utf32                              i r bv)
    (string->utf8                               i r bv)
    (u8-list->bytevector                        i r bv)
    (uint-list->bytevector                      i r bv)
    (utf8->string                               i r bv)
    (utf16->string                              i r bv)
    (utf32->string                              i r bv)
    ;;;
    (condition?                                 i r co)
    (&assertion                                 i r co)
    (assertion-violation?                       i r co)
    (&condition                                 i r co)
    (condition                                  i r co)
    (condition-accessor                         i r co)
    (condition-irritants                        i r co)
    (condition-message                          i r co)
    (condition-predicate                        i r co)
    (condition-who                              i r co)
    (define-condition-type                      i r co)
    (&error                                     i r co)
    (error?                                     i r co)
    (&implementation-restriction                i r co)
    (implementation-restriction-violation?      i r co)
    (&irritants                                 i r co)
    (irritants-condition?                       i r co)
    (&lexical                                   i r co)
    (lexical-violation?                         i r co)
    (make-assertion-violation                   i r co)
    (make-error                                 i r co)
    (make-implementation-restriction-violation  i r co)
    (make-irritants-condition                   i r co)
    (make-lexical-violation                     i r co)
    (make-message-condition                     i r co)
    (make-non-continuable-violation             i r co)
    (make-serious-condition                     i r co)
    (make-syntax-violation                      i r co)
    (make-undefined-violation                   i r co)
    (make-violation                             i r co)
    (make-warning                               i r co)
    (make-who-condition                         i r co)
    (&message                                   i r co)
    (message-condition?                         i r co)
    (&non-continuable                           i r co)
    (non-continuable-violation?                 i r co)
    (&serious                                   i r co)
    (serious-condition?                         i r co)
    (simple-conditions                          i r co)
    (&syntax                                    i r co)
    (syntax-violation                           i r co sc)
    (syntax-violation-form                      i r co)
    (syntax-violation-subform                   i r co)
    (syntax-violation?                          i r co)
    (&undefined                                 i r co)
    (undefined-violation?                       i r co)
    (&violation                                 i r co)
    (violation?                                 i r co)
    (&warning                                   i r co)
    (warning?                                   i r co)
    (&who                                       i r co)
    (who-condition?                             i r co)
    ;;;
    (case-lambda                                i r ct)
    (do                                         i r ct se ne)
    (unless                                     i r ct)
    (when                                       i r ct)
    ;;;
    (define-enumeration                         i r en)
    (enum-set->list                             i r en)
    (enum-set-complement                        i r en)
    (enum-set-constructor                       i r en)
    (enum-set-difference                        i r en)
    (enum-set-indexer                           i r en)
    (enum-set-intersection                      i r en)
    (enum-set-member?                           i r en)
    (enum-set-projection                        i r en)
    (enum-set-subset?                           i r en)
    (enum-set-union                             i r en)
    (enum-set-universe                          i r en)
    (enum-set=?                                 i r en)
    (make-enumeration                           i r en)
    ;;;
    (environment                                i ev)
    (eval                                       i ev se)
    ;;;
    (raise                                      i r ex)
    (raise-continuable                          i r ex)
    (with-exception-handler                     i r ex)
    (guard                                      i r ex)
    ;;;
    (assoc                                      i r ls se)
    (assp                                       i r ls)
    (assq                                       i r ls se)
    (assv                                       i r ls se)
    (cons*                                      i r ls)
    (filter                                     i r ls)
    (find                                       i r ls)
    (fold-left                                  i r ls)
    (fold-right                                 i r ls)
    (for-all                                    i r ls)
    (exists                                     i r ls)
    (member                                     i r ls se)
    (memp                                       i r ls)
    (memq                                       i r ls se)
    (memv                                       i r ls se)
    (partition                                  i r ls)
    (remq                                       i r ls)
    (remp                                       i r ls)
    (remv                                       i r ls)
    (remove                                     i r ls)
    ;;;
    (set-car!                                   i mp se)
    (set-cdr!                                   i mp se)
    ;;;
    (string-set!                                i ms se)
    (string-fill!                               i ms se)
    ;;;
    (command-line                               i r pr)
    (exit                                       i r pr)
    ;;;
    (delay                                      i r5 se ne)
    (exact->inexact                             i r5 se)
    (force                                      i r5 se)
    (inexact->exact                             i r5 se)
    (modulo                                     i r5 se)
    (remainder                                  i r5 se)
    (null-environment                           i r5 se)
    (quotient                                   i r5 se)
    (scheme-report-environment                  i r5 se)
    ;;;
    (binary-port?                               i r ip)
    (buffer-mode                                i r ip)
    (buffer-mode?                               i r ip)
    (bytevector->string                         i r ip)
    (call-with-bytevector-output-port           i r ip)
    (call-with-port                             i r ip)
    (call-with-string-output-port               i r ip)
    (close-port                                 i r ip)
    (eol-style                                  i r ip)
    (error-handling-mode                        i r ip)
    (file-options                               i r ip)
    (flush-output-port                          i r ip)
    (get-bytevector-all                         i r ip)
    (get-bytevector-n                           i r ip)
    (get-bytevector-n!                          i r ip)
    (get-bytevector-some                        i r ip)
    (get-char                                   i r ip)
    (get-datum                                  i r ip)
    (get-line                                   i r ip)
    (get-string-all                             i r ip)
    (get-string-n                               i r ip)
    (get-string-n!                              i r ip)
    (get-u8                                     i r ip)
    (&i/o                                       i r ip is fi)
    (&i/o-decoding                              i r ip)
    (i/o-decoding-error?                        i r ip)
    (&i/o-encoding                              i r ip)
    (i/o-encoding-error-char                    i r ip)
    (i/o-encoding-error?                        i r ip)
    (i/o-error-filename                         i r ip is fi)
    (i/o-error-port                             i r ip is fi)
    (i/o-error?                                 i r ip is fi)
    (&i/o-file-already-exists                   i r ip is fi)
    (i/o-file-already-exists-error?             i r ip is fi)
    (&i/o-file-does-not-exist                   i r ip is fi)
    (i/o-file-does-not-exist-error?             i r ip is fi)
    (&i/o-file-is-read-only                     i r ip is fi)
    (i/o-file-is-read-only-error?               i r ip is fi)
    (&i/o-file-protection                       i r ip is fi)
    (i/o-file-protection-error?                 i r ip is fi)
    (&i/o-filename                              i r ip is fi)
    (i/o-filename-error?                        i r ip is fi)
    (&i/o-invalid-position                      i r ip is fi)
    (i/o-invalid-position-error?                i r ip is fi)
    (&i/o-port                                  i r ip is fi)
    (i/o-port-error?                            i r ip is fi)
    (&i/o-read                                  i r ip is fi)
    (i/o-read-error?                            i r ip is fi)
    (&i/o-write                                 i r ip is fi)
    (i/o-write-error?                           i r ip is fi)
    (lookahead-char                             i r ip)
    (lookahead-u8                               i r ip)
    (make-bytevector                            i r bv)
    (make-custom-binary-input-port              i r ip)
    (make-custom-binary-input/output-port       i r ip)
    (make-custom-binary-output-port             i r ip)
    (make-custom-textual-input-port             i r ip)
    (make-custom-textual-input/output-port      i r ip)
    (make-custom-textual-output-port            i r ip)
    (make-i/o-decoding-error                    i r ip)
    (make-i/o-encoding-error                    i r ip)
    (make-i/o-error                             i r ip is fi)
    (make-i/o-file-already-exists-error         i r ip is fi)
    (make-i/o-file-does-not-exist-error         i r ip is fi)
    (make-i/o-file-is-read-only-error           i r ip is fi)
    (make-i/o-file-protection-error             i r ip is fi)
    (make-i/o-filename-error                    i r ip is fi)
    (make-i/o-invalid-position-error            i r ip is fi)
    (make-i/o-port-error                        i r ip is fi)
    (make-i/o-read-error                        i r ip is fi)
    (make-i/o-write-error                       i r ip is fi)
    (latin-1-codec                              i r ip)
    (make-transcoder                            i r ip)
    (native-eol-style                           i r ip)
    (native-transcoder                          i r ip)
    (open-bytevector-input-port                 i r ip)
    (open-bytevector-output-port                i r ip)
    (open-file-input-port                       i r ip)
    (open-file-input/output-port                i r ip)
    (open-file-output-port                      i r ip)
    (open-string-input-port                     i r ip)
    (open-string-output-port                    i r ip)
    (output-port-buffer-mode                    i r ip)
    (port-eof?                                  i r ip)
    (port-has-port-position?                    i r ip)
    (port-has-set-port-position!?               i r ip)
    (port-position                              i r ip)
    (port-transcoder                            i r ip)
    (port?                                      i r ip)
    (put-bytevector                             i r ip)
    (put-char                                   i r ip)
    (put-datum                                  i r ip)
    (put-string                                 i r ip)
    (put-u8                                     i r ip)
    (set-port-position!                         i r ip)
    (standard-error-port                        i r ip)
    (standard-input-port                        i r ip)
    (standard-output-port                       i r ip)
    (string->bytevector                         i r ip)
    (textual-port?                              i r ip)
    (transcoded-port                            i r ip)
    (transcoder-codec                           i r ip)
    (transcoder-eol-style                       i r ip)
    (transcoder-error-handling-mode             i r ip)
    (utf-16-codec                               i r ip)
    (utf-8-codec                                i r ip)
    ;;;
    (input-port?                                i r is ip se)
    (output-port?                               i r is ip se)
    (current-input-port                         i r ip is se)
    (current-output-port                        i r ip is se)
    (current-error-port                         i r ip is se)
    (eof-object                                 i r ip is se)
    (eof-object?                                i r ip is se)
    (close-input-port                           i r is se)
    (close-output-port                          i r is se)
    (display                                    i r is se)
    (newline                                    i r is se)
    (open-input-file                            i r is se)
    (open-output-file                           i r is se)
    (peek-char                                  i r is se)
    (read                                       i r is se)
    (read-char                                  i r is se)
    (with-input-from-file                       i r is se)
    (with-output-to-file                        i r is se)
    (write                                      i r is se)
    (write-char                                 i r is se)
    (call-with-input-file                       i r is se)
    (call-with-output-file                      i r is se)
    ;;;
    (hashtable-clear!                           i r ht)
    (hashtable-contains?                        i r ht)
    (hashtable-copy                             i r ht)
    (hashtable-delete!                          i r ht)
    (hashtable-entries                          i r ht)
    (hashtable-keys                             i r ht)
    (hashtable-mutable?                         i r ht)
    (hashtable-ref                              i r ht)
    (hashtable-set!                             i r ht)
    (hashtable-size                             i r ht)
    (hashtable-update!                          i r ht)
    (hashtable?                                 i r ht)
    (make-eq-hashtable                          i r ht)
    (make-eqv-hashtable                         i r ht)
    (hashtable-hash-function                    i r ht)
    (make-hashtable                             i r ht)
    (hashtable-equivalence-function             i r ht)
    (equal-hash                                 i r ht)
    (string-hash                                i r ht)
    (string-ci-hash                             i r ht)
    (symbol-hash                                i r ht)
    ;;;
    (list-sort                                  i r sr)
    (vector-sort                                i r sr)
    (vector-sort!                               i r sr)
    ;;;
    (file-exists?                               i r fi)
    (delete-file                                i r fi)
    ;;;
    (define-record-type                         i r rs)
    (fields                                     i r rs)
    (immutable                                  i r rs)
    (mutable                                    i r rs)
    (opaque                                     i r rs)
    (parent                                     i r rs)
    (parent-rtd                                 i r rs)
    (protocol                                   i r rs)
    (record-constructor-descriptor              i r rs)
    (record-type-descriptor                     i r rs)
    (sealed                                     i r rs)
    (nongenerative                              i r rs)
    ;;;
    (record-field-mutable?                      i r ri)
    (record-rtd                                 i r ri)
    (record-type-field-names                    i r ri)
    (record-type-generative?                    i r ri)
    (record-type-name                           i r ri)
    (record-type-opaque?                        i r ri)
    (record-type-parent                         i r ri)
    (record-type-sealed?                        i r ri)
    (record-type-uid                            i r ri)
    (record?                                    i r ri)
    ;;;
    (make-record-constructor-descriptor         i r rp)
    (make-record-type-descriptor                i r rp)
    (record-accessor                            i r rp)
    (record-constructor                         i r rp)
    (record-mutator                             i r rp)
    (record-predicate                           i r rp)
    (record-type-descriptor?                    i r rp)
    ;;;
    (bound-identifier=?                         i r sc)
    (datum->syntax                              i r sc)
    (syntax                                     i r sc)
    (syntax->datum                              i r sc)
    (syntax-case                                i r sc)
    (unsyntax                                   i r sc)
    (unsyntax-splicing                          i r sc)
    (quasisyntax                                i r sc)
    (with-syntax                                i r sc)
    (free-identifier=?                          i r sc)
    (generate-temporaries                       i r sc)
    (identifier?                                i r sc)
    (make-variable-transformer                  i r sc)
    ;;;
    (char-alphabetic?                           i r uc se)
    (char-ci<=?                                 i r uc se)
    (char-ci<?                                  i r uc se)
    (char-ci=?                                  i r uc se)
    (char-ci>=?                                 i r uc se)
    (char-ci>?                                  i r uc se)
    (char-downcase                              i r uc se)
    (char-foldcase                              i r uc)
    (char-titlecase                             i r uc)
    (char-upcase                                i r uc se)
    (char-general-category                      i r uc)
    (char-lower-case?                           i r uc se)
    (char-numeric?                              i r uc se)
    (char-title-case?                           i r uc)
    (char-upper-case?                           i r uc se)
    (char-whitespace?                           i r uc se)
    (string-ci<=?                               i r uc se)
    (string-ci<?                                i r uc se)
    (string-ci=?                                i r uc se)
    (string-ci>=?                               i r uc se)
    (string-ci>?                                i r uc se)
    (string-downcase                            i r uc)
    (string-foldcase                            i r uc)
    (string-normalize-nfc                       i r uc)
    (string-normalize-nfd                       i r uc)
    (string-normalize-nfkc                      i r uc)
    (string-normalize-nfkd                      i r uc)
    (string-titlecase                           i r uc)
    (string-upcase                              i r uc)
    ;;;
    (char-ready?                                se)
    (interaction-environment                    se)
    (load                                       ii)
    ;;;
    (void                                       $boot i)
    (gensym                                     $boot i)
    (symbol-value                               $boot)
    (set-symbol-value!                          $boot)
    (eval-core                                  $boot)
    (pretty-print                               $boot i)
    (module                                     cm)
    (syntax-dispatch ) ; only goes to $all
    (syntax-error    ) ; only goes to $all
    
    (clr-new-array-internal                     is-clr-int)
    (clr-new-internal                           is-clr-int)
    (clr-call-internal                          is-clr-int)
    (clr-cast-internal                          is-clr-int)
    (clr-field-get-internal                     is-clr-int)
    (clr-field-set!-internal                    is-clr-int)
    
    (ironscheme-build                           i)
    (stacktrace                                 ii)
    (license                                    ii)
    (load-r5rs                                  ii)
    (last-pair                                  i)
    (make-list                                  i)
    
    (read-annotated                             ir)
    (annotation?                                ir)
    (annotation-expression                      ir)
    (annotation-source                          ir)
    (annotation-stripped                        ir)
    
    ;;; these should be assigned when creating the record types
    (&condition-rtd)
    (&condition-rcd)
    (&message-rtd)
    (&message-rcd)
    (&warning-rtd)
    (&warning-rcd)
    (&serious-rtd)
    (&serious-rcd)
    (&error-rtd)
    (&error-rcd)
    (&violation-rtd)
    (&violation-rcd)
    (&assertion-rtd)
    (&assertion-rcd)
    (&irritants-rtd)
    (&irritants-rcd)
    (&who-rtd)
    (&who-rcd)
    (&non-continuable-rtd)
    (&non-continuable-rcd)
    (&implementation-restriction-rtd)
    (&implementation-restriction-rcd)
    (&lexical-rtd)
    (&lexical-rcd)
    (&syntax-rtd)
    (&syntax-rcd)
    (&undefined-rtd)
    (&undefined-rcd)
    (&i/o-rtd)
    (&i/o-rcd)
    (&i/o-read-rtd)
    (&i/o-read-rcd)
    (&i/o-write-rtd)
    (&i/o-write-rcd)
    (&i/o-invalid-position-rtd)
    (&i/o-invalid-position-rcd)
    (&i/o-filename-rtd)
    (&i/o-filename-rcd)
    (&i/o-file-protection-rtd)
    (&i/o-file-protection-rcd)
    (&i/o-fie-is-read-only-rtd)
    (&i/o-fie-is-read-only-rcd)
    (&i/o-file-already-exists-rtd)
    (&i/o-file-already-exists-rcd)
    (&i/o-file-does-not-exist-rtd)
    (&i/o-file-does-not-exist-rcd)
    (&i/o-port-rtd)
    (&i/o-port-rcd)
    (&i/o-decoding-rtd)
    (&i/o-decoding-rcd)
    (&i/o-encoding-rtd)
    (&i/o-encoding-rcd)
    (&no-infinities-rtd)
    (&no-infinities-rcd)
    (&no-nans-rtd)
    (&no-nans-rcd)
    ))


(define (verify-map)
  (define (f x)
    (for-each
      (lambda (x)
        (unless (assq x library-legend)
          (error 'verify "not in the libraries list" x)))
      (cdr x)))
  (for-each f identifier->library-map))

(define (make-collection)
  (let ((set '()))
    (case-lambda
      (() set)
      ((x) (set! set (cons x set))))))


(define (make-system-data subst env)
  (define who 'make-system-data)
  (let ((export-subst    (make-collection))
        (export-env      (make-collection))
        (export-primlocs (make-collection)))
    (for-each
      (lambda (x)
        (let ((name (car x)) (binding (cadr x)))
          (let ((label (gensym)))
            (export-subst (cons name label))
            (export-env   (cons label binding)))))
      psyntax-system-macros)
    (for-each
      (lambda (x)
        (cond
          ((macro-identifier x) (values))
          ((assq x (export-subst))
           (error who "ambiguous export" x))
          ((assq x subst) =>
           ;;; primitive defined (exported) within the compiled libraries
           (lambda (p)
             (let ((label (cdr p)))
               (cond
                 ((assq label env) =>
                  (lambda (p)
                    (let ((binding (cdr p)))
                      (case (car binding)
                        ((global)
                         (export-subst (cons x label))
                         (export-env   (cons label (cons 'core-prim x)))
                         (export-primlocs (cons x (cdr binding))))
                        (else
                         (error #f "invalid binding for identifier" p x))))))
                 (else
                  (error #f "cannot find binding" x label))))))
          (else
           ;;; core primitive with no backing definition, assumed to
           ;;; be defined in other strata of the system
           (let ((label (gensym)))
             (export-subst (cons x label))
             (export-env (cons label (cons 'core-prim x)))))))
      (map car identifier->library-map))
    (values (export-subst) (export-env) (export-primlocs))))

(define (get-export-subset key subst)
  (let f ((ls subst))
    (cond
      ((null? ls) '())
      (else
       (let ((x (car ls)))
         (let ((name (car x)))
           (cond
             ((assq name identifier->library-map)
              =>
              (lambda (q)
                (cond
                  ((memq key (cdr q))
                   (cons x (f (cdr ls))))
                  (else (f (cdr ls))))))
             (else
              ;;; not going to any library?
              (f (cdr ls))))))))))

(define (build-system-library export-subst export-env primlocs)
  (define (build-library legend-entry)
    (let ((key (car legend-entry))
          (name (cadr legend-entry))
          (visible? (caddr legend-entry)))
      (let ((id     (gensym))
            (name       name)
            (version     (if (eq? (car name) 'rnrs) '(6) '()))
            (import-libs '())
            (visit-libs  '())
            (invoke-libs '()))
        (let-values (((subst env)
                      (if (equal? name '(psyntax system $all))
                          (values export-subst export-env)
                          (values
                            (get-export-subset key export-subst)
                            '()))))
          `(install-library
             ',id ',name ',version ',import-libs ',visit-libs ',invoke-libs
             ',subst ',env values values ',visible?)))))
  (let ((code `(library (psyntax primlocs)
                  (export) ;;; must be empty
                  (import
                    (only (psyntax library-manager)
                          install-library)
                    (only (psyntax internal)
                          current-primitive-locations)
                    (rnrs lists)
                    (rnrs base))
                  (current-primitive-locations
                    (lambda (x)
                      (cond
                        ((assq x ',primlocs) => cdr)
                        (else #f))))
                  ,@(map build-library library-legend))))
    (let-values (((code empty-subst empty-env)
                  (boot-library-expand code)))
       code)))

(define (make-init-code)
  (values '() '() '()))

(define (expand-all files)
  ;;; remove all re-exported identifiers (those with labels in
  ;;; subst but not binding in env).
  (define (prune-subst subst env)
    (cond
      ((null? subst) '())
      ((not (assq (cdar subst) env)) (prune-subst (cdr subst) env))
      (else (cons (car subst) (prune-subst (cdr subst) env)))))
  (define (load file proc)
    (with-input-from-file file
       (lambda ()
         (let f ()
           (let ((x (read-annotated)))
             (unless (eof-object? x) 
               (proc x)
               (f)))))))
  (let-values (((code* subst env) (make-init-code)))
    (for-each
      (lambda (file)
        (display "expanding ")
        (display file)
        (newline)
        (load file
          (lambda (x)
            (let-values (((code export-subst export-env)
                          (boot-library-expand x)))
               (set! code* (cons code code*))
               (set! subst (append export-subst subst))
               (set! env (append export-env env))))))
      files)
    (let-values (((export-subst export-env export-locs)
                  (make-system-data (prune-subst subst env) env)))
      (let ((code (build-system-library export-subst export-env export-locs)))
        (values
          (reverse (cons* (car code*) code (cdr code*)))
          export-locs)))))



(define bootstrap-collection
  (let ((ls '()))
    (case-lambda
      (() ls)
      ((x) 
       (unless (memq x ls) 
         (set! ls (cons x ls)))))))

(verify-map)

(let ((all-names (map car identifier->library-map))
      (all-labels (map (lambda (x) (gensym)) identifier->library-map))
      (all-bindings (map (lambda (x) 
                           (cond
                             ((macro-identifier x) => cadr)
                             (else `(core-prim . ,x))))
                         (map car identifier->library-map))))
  (let ((export-subst (map cons all-names all-labels))
        (export-env (map cons all-labels all-bindings)))
    (define (build-library legend-entry)
      (let ((key (car legend-entry))
            (name (cadr legend-entry))
            (visible? (caddr legend-entry))
            (required? (cadddr legend-entry)))
        (when required?
          (let ((id     (gensym))
                (name       name)
                (version     (if (eq? (car name) 'rnrs) '(6) '()))
                (import-libs '())
                (visit-libs  '())
                (invoke-libs '()))
            (let-values (((subst env)
                          (if (equal? name '(psyntax system $all))
                              (values export-subst export-env)
                              (values
                                (get-export-subset key export-subst)
                                '()))))
              (parameterize ((current-library-collection 
                              bootstrap-collection))
                (install-library
                   id name version import-libs visit-libs invoke-libs
                   subst env values values visible?)))))))
    (for-each build-library library-legend)))


(let ()
  (define-syntax define-prims
    (syntax-rules ()
      ((_ name* ...)
       (let ((g* (map (lambda (x) (gensym)) '(name* ...)))
             (v* (list name* ...)))
         (for-each set-symbol-value! g* v*)
         (let ((alist (map cons '(name* ...) g*)))
           (current-primitive-locations
             (lambda (x) 
               (cond
                 ((assq x alist) => cdr)
                 (else (error #f "undefined prim ~s" x))))))))))
  (define-prims
    syntax-dispatch apply cons append map list syntax-error
    generate-temporaries = + datum->syntax string->symbol
    string-append symbol->string syntax->datum gensym length 
    open-string-output-port identifier? free-identifier=? exists
    values call-with-values for-all))

(time-it "the entire bootstrap process"  
  (lambda () 
    (let-values (((core* locs)
                   (time-it "macro expansion"  
                     (lambda ()   
                       (parameterize ((current-library-collection bootstrap-collection))
                         (expand-all scheme-library-files))))))
        (current-primitive-locations
          (lambda (x)
            (cond
              ((assq x locs) => cdr)
              (else #f))))
        (when (file-exists? "ironscheme.boot.pp")
          (delete-file "ironscheme.boot.pp"))
        (let ((p (open-output-file "ironscheme.boot.pp")))
          (display ";;; Copyright (c) 2006, 2007 Abdulaziz Ghuloum and Kent Dybvig" p) (newline p)
          (display ";;; Copyright (c) 2007 Llewellyn Pritchard" p) (newline p)
          (display ";;; automatically generated from psyntax & ironscheme sources" p) (newline p)
          (display ";;; for copyright details, see psyntax/main.ss" p) (newline p) (newline p)
          (time-it "code generation and pretty-print"  
            (lambda ()  
              (for-each
                (lambda (x)
                  (compile-core-expr-to-port x p)
                  (newline p))
                core*)))
          (close-output-port p)))))

(display "IronScheme build completed.\n")


;;; vim:syntax=scheme
